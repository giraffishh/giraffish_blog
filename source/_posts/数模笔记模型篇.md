---
index_img: 'https://img.picgo.net/2025/05/31/25-05-31-174868501780081c5020678b86acf.webp'
banner_img: 'https://img.picgo.net/2025/05/31/25-05-31-174868456032966958ff522538315.webp'
title: 数模笔记模型篇
categories:
  - 学习笔记
tags:
  - 数学建模
comments: true
abbrlink: 51e2c075
date: 2025-05-31 19:42:50
updated: 2025-05-31 19:51:50
---
## 线性规划（LP）

### 一般形式

![](https://img.picgo.net/2025/05/31/25-05-31-1748681029505759b640b31607dc8.png)

**可行解：** 满足约束条件（4）的解 $x = [x_1, \ldots, x_n]^T$，称为线性规划问题的可行解，而使目标函数（3）达到最大值的可行解叫最优解。  

**可行域：** 可行解构成的集合称为问题的可行域，记为 $R$

使用 `scipy.optimize.linprog` 解 LP 的代码模板

> 25.6.25更新：`scipy.optimize.linprog`狗都不用，直接用PuLP库太香了

```python
from scipy.optimize import linprog

# 目标函数系数 c（注意是最小化）
c = [cost1, cost2, ..., costn]  # 要求最小化 c^T x

# 不等式约束：Ax ≤ b, 若Ax ≥ b则两边同时取负号−Ax ≤ −b
A = [
    [a11, a12, ..., a1n],
    [a21, a22, ..., a2n],
    ...
]
b = [b1, b2, ..., bm]

# 等式约束：Aeq x = beq（可选）
A_eq = [
    [aeq11, aeq12, ..., aeq1n],
    ...
]
b_eq = [beq1, beq2, ...]

# 变量范围：每个变量 x_i 的 (min, max)
bounds = [(lb1, ub1), (lb2, ub2), ..., (lbn, ubn)]

# 求解
res = linprog(c, A_ub=A, b_ub=b, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method="highs")

# 输出结果
if res.success:
    print("最小值:", res.fun)
    print("最优解 x:", res.x)
else:
    print("求解失败:", res.message)
```

> 若求最大值就在目标函数c处加负号
>
> 例如：最大化利润 40x + 30y → 最小化 -40x -30y
> 则 `c = [-40, -30]`

非线性的有时候也可以转化为线性规划的问题

![](https://img.picgo.net/2025/05/31/25-05-31-1748683411323f0172724c3fe79bd.webp)

***

### 例题

市场上有 $n$ 种资产 $S_i$（$i = 1, 2, \ldots, n$）可以选择，现用数额为 $M$ 的相当大的资金作一个时期的投资。这 $n$ 种资产在这一时期内购买 $S_i$ 的平均收益率为 $r_i$，风险损失率为 $q_i$。投资越分散，总的风险越少，总体风险可用投资的 $S_i$ 中最大的一个风险来度量。

购买 $S_i$ 时要付交易费，费率为 $p_i$，当购买额不超过给定值 $u_i$ 时，交易费按购买 $u_i$ 计算。另外，假定同期银行存款利率是 $r_0$（$r_0 = 5\%$），既无交易费又无风险。

已知 $n = 4$ 时相关数据如下：

| 资产 $S_i$ | 收益率 $r_i(\%)$ | 风险率 $q_i(\%)$ | 交易费率 $p_i(\%)$ | 交易费阈值 $u_i$(元) |
|------------|------------------|------------------|--------------------|-----------------------|
| $S_1$      | 28               | 2.5              | 1                  | 103                   |
| $S_2$      | 21               | 1.5              | 2                  | 198                   |
| $S_3$      | 23               | 5.5              | 4.5                | 52                    |
| $S_4$      | 25               | 2.6              | 6.5                | 40                    |

**投资目标** 
用给定资金 $M$，有选择地购买若干种资产或存银行生息（无风险利率 $r_0=5\%$），要求：

1. 净收益尽可能大
2. 总体风险（定义为所投资资产中最大单个风险）尽可能小

### 解答

#### 符号规定

| 符号 | 说明 |
|------|------|
| $s_i$ | 第 $i$ 种投资项目（$i = 0,1,\ldots,n$），其中 $s_0$ 表示存入银行 |
| $r_i$ | $s_i$ 的平均收益率（$i = 0,\ldots,n$） |
| $p_i$ | $s_i$ 的交易费率（$i = 0,\ldots,n$），其中 $p_0 = 0$ |
| $q_i$ | $s_i$ 的风险损失率（$i = 0,\ldots,n$），其中 $q_0 = 0$ |
| $u_i$ | $s_i$ 的交易定额（$i = 1,\ldots,n$） |
| $x_i$ | 投资项目 $s_i$ 的资金（$i = 0,1,\ldots,n$） |
| $a$   | 投资风险度 |
| $Q$   | 总体收益 |

#### 基本假设

* 投资规模
   投资数额 $M$ 相当大，为便于计算，设 $M = 1$（单位化处理）

* 风险分散性
   投资越分散，总风险越小

* 风险度量
   总体风险定义为所有投资项目 $s_i$ 中最大的单个风险，即 $\max(q_i x_i)$，其中 $x_i$ 为投资比例

* 资产独立性
   $n + 1$ 种资产 $s_i$（含银行存款）之间相互独立

* 参数稳定性
   在投资期内，各资产的参数为定值，不受其他意外因素影响： 
   - 收益率 $r_i$ 
   - 交易费率 $p_i$ 
   - 风险损失率 $q_i$ 

* 收益与风险的决定性
   净收益和总体风险仅由 $r_i, p_i, q_i$ 决定，不受其他因素干扰

#### 模型关键定义

* 总体风险度量
   总体风险定义为所投资资产中最大单项风险：
   $$\max \{ q_i x_i \mid i = 1, 2, \ldots, n \}.$$

* 交易费分段函数
   购买资产 $s_i$ ($i = 1, \ldots, n$) 的交易费计算规则： 
   $$
   \text{交易费} = 
   \begin{cases} 
   p_i x_i, & x_i > u_i; \\ 
   p_i u_i, & x_i \leq u_i.
   \end{cases}
   $$
   > 简化假设：由于 $u_i$ 和 $p_i u_i$ 相对总投资 $M$ 极小，净收益可近似为 $(r_i - p_i)x_i$

* 多目标规划性质
   目标函数需同时满足： 

   - 净收益 $(r_i - p_i)x_i$ 最大化 
   - 总体风险 $\max(q_i x_i)$ 最小化 
     （需通过多目标优化方法求解）
     

**总结一下：**
$$
\text{目标函数}
\begin{cases} 
\max \sum\limits_{i=0}^n (r_i - p_i)x_i & \text{(最大化净收益)} \\ 
\min \max \{q_i x_i\} & \text{(最小化最大单项风险)}
\end{cases}
$$

$$
\text{约束条件}
\begin{cases} 
\sum\limits_{i=0}^n (1 + p_i)x_i = M & \text{(总资金约束)} \\ 
x_i \geq 0, & i = 0,1,\cdots,n
\end{cases}
$$

#### 转化为线性规划问题

**模型一：** 固定风险水平下的收益优化模型

通过引入风险承受界限 $a$，将多目标规划转化为**单目标线性规划**：
- 限定最大风险：$\max \frac{q_i x_i}{M} \leq a$
- 单一优化目标：最大化净收益

**目标函数** 
$$
\max \sum_{i=0}^n (r_i - p_i)x_i
$$

**约束条件** 
$$
\begin{cases}
\frac{q_i x_i}{M} \leq a, & i=1,\ldots,n \quad \text{(单项风险控制)} \\
\sum\limits_{i=0}^n (1 + p_i)x_i = M, & \text{(资金总量约束)} \\
x_i \geq 0, & i=0,1,\ldots,n \quad \text{(非负投资)}
\end{cases}
$$

***

**模型二：** 固定收益下的风险最小化

**目标函数** 
$$
\min \{\max \{ q_i x_i \}\}
$$

**约束条件** 
$$
\begin{cases}
\sum\limits_{i=0}^n (r_i - p_i)x_i \geq k & \text{(最低收益要求)} \\
\sum\limits_{i=0}^n (1 + p_i)x_i = M & \text{(资金总量约束)} \\
x_i \geq 0, & i=0,1,\ldots,n
\end{cases}
$$

***

**模型三：** 风险-收益加权优化

投资者在权衡资产风险和预期收益两方面时，希望选择一个令自己满意的投资组合。因此对风险、收益分别赋予权重 $s$（$0 < s \leq 1$）和 $(1-s)$，$s$称为投资偏好系数

**目标函数** 
$$
\min \left[ s \cdot \max \{ q_i x_i \} - (1-s) \sum\limits_{i=0}^n (r_i - p_i)x_i \right]
$$

**约束条件** 
$$
\begin{cases}
\sum\limits_{i=0}^n (1 + p_i)x_i = M \\
x_i \geq 0, & i=0,1,\ldots,n
\end{cases}
$$

## 整数规划（ILP）

### 整数规划特点

原线性规划有最优解，当自变量限制为整数后，其整数规划解出现下述情况

1. 原线性规划最优解全是整数，则整数规划最优解与线性规划最优解一致
2. 整数规划无可行解
3. 有可行解（当然就存在最优解），但最优解值变差

> 整数规划最优解不能按照实数最优解简单取整而获得，可能会超出可行域

**整数规划分类:**

* 纯整数规划：所有决策变量要求取非负整数（这时引进的松弛变量和剩余变量可以不要求取整数）
* 全整数规划：除了所有决策变量要求取非负整数外，系数$a_{ij}$和常数$b_i$也要求取整数（这时引进的松弛变量和剩余变量也必须是整数）
* 混合整数规划：只有一部分的决策变量要求取非负整数，另一部分可以取非负实数
* 0—1整数规划：所有决策变量只能取0或1两个整数

> **松弛变量:** $x_1 + x_2 \geq 10$ 引入 $x_3$ → $x_1 + x_2 + x_3 = 10$，$x_3 \geq 0$
> **剩余变量:** $x_1 + x_2 \geq 10$ 引入 $x_3$ → $x_1 + x_2 - x_3 = 10$，$x_3 \leq 0$
> 松弛变量和剩余变量的目的是将**不等式约束**转化为**等式约束**

整数规划与松弛的线性规划的关系：

* 整数规划可行解是松弛问题可行域中的整数格点松弛问题无可行解，则整数规划无可行解
* ILP最优值小于或等于松弛问题的最优值
* 松弛问题最优解满足整数要求，则该最优解为整数规划最优解


### 一般形式

$$
\max(\min) \, z = \sum_{j=1}^n c_j x_j
$$

$$
\begin{cases} 
\sum_{j=1}^n a_{ij} x_j \leq (=, \geq) b_i & (i = 1, 2, \ldots m) \\ 
x_j \geq 0, & x_j \text{为整数} \, (j = 1, 2, \ldots n)
\end{cases}
$$

### 分支定界算法 (Deprecated)

1. 不考虑整数限制先求出相应松弛问题的最优解

若不满足整数条件，则任选一个不满足整数条件的变量 $x_i^0$ 来构造新的约束添加到松弛问题中形成两个子问题：

$$
x_i \leq \left\lfloor x_i^0 \right\rfloor
$$
$$
x_i \geq \left\lfloor x_i^0 \right\rfloor + 1
$$

2. 缩小的可行域中求解新构造的线性规划的最优解，并重复上述过程，直到子问题无解或有整数最优解（被查清）

**示例:**

$$
\max z = 3x_1 + 2x_2
$$

$$
\begin{cases} 
2x_1 + 3x_2 \leq 14 \\
2x_1 + x_2 \leq 9 \\ 
x_1, x_2 \geq 0 
\end{cases}
$$

```python
import numpy as np
from scipy.optimize import linprog
import matplotlib.pyplot as plt
from collections import deque


class BranchAndBoundSolver:
    """分支定界法求解器类"""

    def __init__(self):
        """初始化求解器"""
        self.best_solution = None  # 最优解
        self.best_value = float('-inf')  # 最优目标函数值
        self.nodes_explored = 0  # 已探索节点数

    def solve_lp_relaxation(self, c, A_ub, b_ub, bounds):
        """
        求解线性规划松弛问题
        参数:
            c: 目标函数系数
            A_ub: 不等式约束系数矩阵
            b_ub: 不等式约束右端向量
            bounds: 变量边界
        返回:
            目标函数值, 解向量
        """
        # scipy求最小值，目标函数系数取负数转换为最大值问题
        result = linprog(-c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

        if result.success:
            return -result.fun, result.x  # 返回最大值和解
        else:
            return None, None

    def is_integer_solution(self, x, tolerance=1e-6):
        """检查解是否为整数解"""
        return all(abs(xi - round(xi)) < tolerance for xi in x)

    def find_fractional_variable(self, x, tolerance=1e-6):
        """找到第一个非整数变量的索引"""
        for i, xi in enumerate(x):
            if abs(xi - round(xi)) >= tolerance:
                return i
        return None

    def solve(self, c, A_ub, b_ub, initial_bounds):
        """
        主求解函数 - 分支定界法
        参数:
            c: 目标函数系数
            A_ub: 约束矩阵
            b_ub: 约束右端向量
            initial_bounds: 初始变量边界
        """
        # 用队列存储待处理的节点 (边界, 深度)
        queue = deque([(initial_bounds, 0)])

        print("开始分支定界法求解...")
        print("=" * 50)

        while queue:
            current_bounds, depth = queue.popleft()
            self.nodes_explored += 1

            print(f"\n节点 {self.nodes_explored}:")
            print(f"边界: x1∈{current_bounds[0]}, x2∈{current_bounds[1]}")

            # 求解当前节点的LP松弛
            obj_value, solution = self.solve_lp_relaxation(c, A_ub, b_ub, current_bounds)

            if obj_value is None:
                print("  无可行解")
                continue

            print(f"  LP解: x1={solution[0]:.3f}, x2={solution[1]:.3f}, z={obj_value:.3f}")

            # 剪枝：如果上界不能改进当前最优解
            if obj_value <= self.best_value:
                print(f"  剪枝: {obj_value:.3f} ≤ {self.best_value}")
                continue

            # 检查是否为整数解
            if self.is_integer_solution(solution):
                print("  *** 找到整数解! ***")
                if obj_value > self.best_value:
                    self.best_value = obj_value
                    self.best_solution = solution.copy()
                    print(f"  *** 更新最优解: z={obj_value} ***")
                continue

            # 分支：选择第一个非整数变量
            branch_var = self.find_fractional_variable(solution)
            if branch_var is not None:
                branch_value = solution[branch_var]
                print(f"  分支变量: x{branch_var + 1}={branch_value:.3f}")

                # 创建左右两个子问题
                left_bounds = [list(bound) if isinstance(bound, tuple) else bound for bound in current_bounds]
                right_bounds = [list(bound) if isinstance(bound, tuple) else bound for bound in current_bounds]

                # 左分支: x[branch_var] <= floor(branch_value)
                left_bounds[branch_var] = (left_bounds[branch_var][0], int(branch_value))
                # 右分支: x[branch_var] >= ceil(branch_value)
                right_bounds[branch_var] = (int(branch_value) + 1, right_bounds[branch_var][1])

                # 添加子问题到队列
                queue.append((left_bounds, depth + 1))
                queue.append((right_bounds, depth + 1))

        # 输出最终结果
        print("\n" + "=" * 50)
        print("求解完成!")
        print(f"探索节点数: {self.nodes_explored}")

        if self.best_solution is not None:
            print(f"最优解: x1={int(self.best_solution[0])}, x2={int(self.best_solution[1])}")
            print(f"最优值: z={self.best_value}")
        else:
            print("未找到可行解")

    def visualize_problem(self, c, A_ub, b_ub):
        """
        可视化问题的可行域和解
        参数:
            c: 目标函数系数
            A_ub: 约束矩阵
            b_ub: 约束右端向量
        """
        # 创建图形
        plt.figure(figsize=(10, 8))

        # 定义x1的范围
        x1 = np.linspace(0, 6, 100)

        # 绘制约束线
        # 约束1: 2x1 + 3x2 <= 14
        x2_1 = (14 - 2 * x1) / 3
        plt.plot(x1, x2_1, 'b-', label='2x₁ + 3x₂ ≤ 14', linewidth=2)

        # 约束2: 2x1 + x2 <= 9
        x2_2 = 9 - 2 * x1
        plt.plot(x1, x2_2, 'r-', label='2x₁ + x₂ ≤ 9', linewidth=2)

        # 填充可行域
        x1_fill = np.linspace(0, 4.5, 100)
        x2_fill1 = np.minimum((14 - 2 * x1_fill) / 3, 9 - 2 * x1_fill)
        x2_fill2 = np.zeros_like(x1_fill)
        plt.fill_between(x1_fill, x2_fill2, np.maximum(x2_fill1, 0),
                         alpha=0.3, color='lightblue', label='Feasible Region')

        # 绘制目标函数等值线
        X1, X2 = np.meshgrid(np.linspace(0, 6, 50), np.linspace(0, 6, 50))
        Z = 3 * X1 + 2 * X2
        contours = plt.contour(X1, X2, Z, levels=8, colors='green', alpha=0.6)
        plt.clabel(contours, inline=True, fontsize=8)

        # 标记所有整数点
        for i in range(6):
            for j in range(6):
                if 2 * i + 3 * j <= 14 and 2 * i + j <= 9 and i >= 0 and j >= 0:
                    plt.plot(i, j, 'ko', markersize=6)

        # 标记最优解
        if self.best_solution is not None:
            x1_opt, x2_opt = int(self.best_solution[0]), int(self.best_solution[1])
            plt.plot(x1_opt, x2_opt, 'ro', markersize=12,
                     label=f'Optimal Solution ({x1_opt}, {x2_opt})')

        # 设置图形属性
        plt.xlim(0, 6)
        plt.ylim(0, 6)
        plt.xlabel('x₁')
        plt.ylabel('x₂')
        plt.title('Integer Linear Programming Problem\nmax z = 3x₁ + 2x₂')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()


def main():
    """主函数 - 定义问题并求解"""

    # 1. 定义问题参数
    print("线性整数规划问题:")
    print("目标函数: max z = 3x₁ + 2x₂")
    print("约束条件:")
    print("  2x₁ + 3x₂ ≤ 14")
    print("  2x₁ + x₂ ≤ 9")
    print("  x₁, x₂ ≥ 0 且为整数")

    # 目标函数系数
    c = np.array([3, 2])

    # 约束矩阵和右端向量
    A_ub = np.array([
        [2, 3],  # 第一个约束: 2x₁ + 3x₂ ≤ 14
        [2, 1]  # 第二个约束: 2x₁ + x₂ ≤ 9
    ])
    b_ub = np.array([14, 9])

    # 变量边界 (下界, 上界)
    initial_bounds = [(0, 10), (0, 10)]

    # 2. 创建求解器并求解
    solver = BranchAndBoundSolver()
    solver.solve(c, A_ub, b_ub, initial_bounds)

    # 3. 可视化结果
    solver.visualize_problem(c, A_ub, b_ub)

    # 4. 验证解的正确性
    if solver.best_solution is not None:
        x1, x2 = int(solver.best_solution[0]), int(solver.best_solution[1])
        print(f"\n解的验证:")

        # 检查约束条件
        constraint1 = 2 * x1 + 3 * x2
        constraint2 = 2 * x1 + x2
        objective = 3 * x1 + 2 * x2

        print(f"约束1: 2×{x1} + 3×{x2} = {constraint1} ≤ 14 ✓" if constraint1 <= 14 else "约束1违反!")
        print(f"约束2: 2×{x1} + 1×{x2} = {constraint2} ≤ 9 ✓" if constraint2 <= 9 else "约束2违反!")
        print(f"目标函数: 3×{x1} + 2×{x2} = {objective}")

        # 5. 与LP松弛解比较
        print(f"\n与LP松弛解的比较:")
        result = linprog(-c, A_ub=A_ub, b_ub=b_ub, bounds=[(0, None), (0, None)], method='highs')
        if result.success:
            lp_solution = result.x
            lp_value = -result.fun
            print(f"LP松弛解: x₁={lp_solution[0]:.3f}, x₂={lp_solution[1]:.3f}")
            print(f"LP松弛值: z={lp_value:.3f}")
            print(f"整数解值: z={objective}")
            print(f"最优性间隙: {lp_value - objective:.3f}")


if __name__ == "__main__":
    main()
```

输出：
```
线性整数规划问题:
目标函数: max z = 3x₁ + 2x₂
约束条件:
  2x₁ + 3x₂ ≤ 14
  2x₁ + x₂ ≤ 9
  x₁, x₂ ≥ 0 且为整数
开始分支定界法求解...
==================================================

节点 1:
边界: x1∈(0, 10), x2∈(0, 10)
  LP解: x1=3.250, x2=2.500, z=14.750
  分支变量: x1=3.250

节点 2:
边界: x1∈(0, 3), x2∈[0, 10]
  LP解: x1=3.000, x2=2.667, z=14.333
  分支变量: x2=2.667

节点 3:
边界: x1∈(4, 10), x2∈[0, 10]
  LP解: x1=4.000, x2=1.000, z=14.000
  *** 找到整数解! ***
  *** 更新最优解: z=14.0 ***

节点 4:
边界: x1∈[0, 3], x2∈(0, 2)
  LP解: x1=3.000, x2=2.000, z=13.000
  剪枝: 13.000 ≤ 14.0

节点 5:
边界: x1∈[0, 3], x2∈(3, 10)
  LP解: x1=2.500, x2=3.000, z=13.500
  剪枝: 13.500 ≤ 14.0

==================================================
求解完成!
探索节点数: 5
最优解: x1=4, x2=1
最优值: z=14.0

解的验证:
约束1: 2×4 + 3×1 = 11 ≤ 14 ✓
约束2: 2×4 + 1×1 = 9 ≤ 9 ✓
目标函数: 3×4 + 2×1 = 14

与LP松弛解的比较:
LP松弛解: x₁=3.250, x₂=2.500
LP松弛值: z=14.750
整数解值: z=14
最优性间隙: 0.750
```

![](https://img.picgo.net/2025/06/16/25-06-16-175004514590479b9292c028352c4.webp)

### PuLP库

PuLP是一个功能强大的Python库，专门用于解决线性规划、整数规划和混合整数规划问题

**示例:**
```python
import pulp


def solve_integer_programming_with_pulp():
    """
    使用PuLP求解整数线性规划问题

    问题描述:
    最大化: z = 3x₁ + 2x₂
    约束条件:
        2x₁ + 3x₂ ≤ 14
        2x₁ + x₂ ≤ 9
        x₁, x₂ ≥ 0 且为整数
    """

    # 步骤1: 创建问题实例
    prob = pulp.LpProblem("Integer_Linear_Programming", pulp.LpMaximize)

    # 步骤2: 定义决策变量（整数变量）
    x1 = pulp.LpVariable("x1", lowBound=0, cat='Integer')
    x2 = pulp.LpVariable("x2", lowBound=0, cat='Integer')

    # 步骤3: 添加目标函数
    prob += 3 * x1 + 2 * x2, "Objective_Function"

    # 步骤4: 添加约束条件
    prob += 2 * x1 + 3 * x2 <= 14, "Material_Constraint"
    prob += 2 * x1 + x2 <= 9, "Time_Constraint"

    # 步骤5: 求解问题
    print("Solving the problem...")
    prob.solve(pulp.PULP_CBC_CMD(msg=0))  # msg=0 隐藏求解器详细输出

    # 步骤6: 检查求解状态
    print(f"Status: {pulp.LpStatus[prob.status]}")

    # 步骤7: 输出结果
    if prob.status == pulp.LpStatusOptimal:
        print("\nOptimal Solution Found!")
        print(f"x₁ = {int(x1.varValue)}")
        print(f"x₂ = {int(x2.varValue)}")
        print(f"Maximum objective value z = {int(pulp.value(prob.objective))}")

        # 验证约束条件
        print("\nConstraint Verification:")
        x1_val = int(x1.varValue)
        x2_val = int(x2.varValue)

        constraint1_value = 2 * x1_val + 3 * x2_val
        constraint2_value = 2 * x1_val + x2_val

        print(f"Constraint 1: 2×{x1_val} + 3×{x2_val} = {constraint1_value} ≤ 14 ✓")
        print(f"Constraint 2: 2×{x1_val} + 1×{x2_val} = {constraint2_value} ≤ 9 ✓")

        return x1_val, x2_val, int(pulp.value(prob.objective))
    else:
        print("No optimal solution found!")
        return None

def main():
    solve_integer_programming_with_pulp()

if __name__ == "__main__":
    main()
```

## 非线性规划（NP）

### 一般形式

$$
\min f(x)
$$

$$
\begin{cases}
A \cdot x \leq b \\
Aeq \cdot x = beq \\
c(x) \leq 0 \\
ceq(x) = 0 \\
lb \leq x \leq ub
\end{cases}
$$


其中：
- $f(x)$ 是标量目标函数
- $A$, $b$, $Aeq$, $beq$ 是线性约束的矩阵和向量
- $c(x)$, $ceq(x)$ 是非线性约束函数
- $lb$, $ub$ 是变量的下界和上界

### Pyomo库

[Pyomo](https://pyomo.readthedocs.io/en/stable/)作为一个功能强大的Python优化建模语言，能够处理广泛的数学规划问题

具体包括：

**线性规划问题**

- 标准线性规划（LP）
- 混合整数线性规划（MILP）

**非线性规划问题**

- 非线性规划（NLP）
- 混合整数非线性规划（MINLP）
- 混合整数二次规划（MIQP）

**特殊问题类型**

- 二次规划（QP）
- 随机规划
- 双层规划问题
- 广义析取规划
- 带平衡约束的数学规划
- 微分代数方程优化问题

> Pyomo和求解器的安装建议用conda而不是普通的虚拟环境，不然会遇到奇妙bug（

**NLP示例代码:**
```python
import pyomo.environ as pyo
import numpy as np
import matplotlib.pyplot as plt
from pyomo.opt import SolverStatus, TerminationCondition

# 设置matplotlib使用英文字体
plt.rcParams['font.family'] = ['DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False


class NonlinearProgrammingSolver:
    """使用Pyomo求解非线性规划问题的类"""

    def __init__(self):
        self.model = None
        self.solver = None
        self.results = None

    def create_general_nlp_model(self, n_vars=2):
        """
        创建通用非线性规划模型

        参数:
            n_vars: 变量个数
        """
        # 创建模型
        self.model = pyo.ConcreteModel("Nonlinear_Programming")

        # 定义变量索引集合
        self.model.I = pyo.RangeSet(1, n_vars)

        # 定义决策变量
        self.model.x = pyo.Var(self.model.I, within=pyo.Reals)

        print(f"Created general NLP model with {n_vars} variables")
        return self.model

    def add_linear_constraints(self, A=None, b=None, Aeq=None, beq=None):
        """
        添加线性约束

        参数:
            A: 不等式约束矩阵 (A·x ≤ b)
            b: 不等式约束右端向量
            Aeq: 等式约束矩阵 (Aeq·x = beq)
            beq: 等式约束右端向量
        """
        if A is not None and b is not None:
            # 添加不等式约束 A·x ≤ b
            A = np.array(A)
            b = np.array(b)

            def inequality_constraint_rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) <= b[i - 1]

            self.model.ineq_constraints = pyo.Constraint(
                pyo.RangeSet(1, len(b)),
                rule=inequality_constraint_rule
            )
            print(f"Added {len(b)} inequality constraints")

        if Aeq is not None and beq is not None:
            # 添加等式约束 Aeq·x = beq
            Aeq = np.array(Aeq)
            beq = np.array(beq)

            def equality_constraint_rule(model, i):
                return sum(Aeq[i - 1, j - 1] * model.x[j] for j in model.I) == beq[i - 1]

            self.model.eq_constraints = pyo.Constraint(
                pyo.RangeSet(1, len(beq)),
                rule=equality_constraint_rule
            )
            print(f"Added {len(beq)} equality constraints")

    def add_nonlinear_constraints(self, c_functions=None, ceq_functions=None):
        """
        添加非线性约束

        参数:
            c_functions: 不等式约束函数列表 [c1(x), c2(x), ...] ≤ 0
            ceq_functions: 等式约束函数列表 [ceq1(x), ceq2(x), ...] = 0
        """
        if c_functions:
            # 添加非线性不等式约束
            def nonlinear_ineq_rule(model, i):
                return c_functions[i - 1](model) <= 0

            self.model.nonlinear_ineq = pyo.Constraint(
                pyo.RangeSet(1, len(c_functions)),
                rule=nonlinear_ineq_rule
            )
            print(f"Added {len(c_functions)} nonlinear inequality constraints")

        if ceq_functions:
            # 添加非线性等式约束
            def nonlinear_eq_rule(model, i):
                return ceq_functions[i - 1](model) == 0

            self.model.nonlinear_eq = pyo.Constraint(
                pyo.RangeSet(1, len(ceq_functions)),
                rule=nonlinear_eq_rule
            )
            print(f"Added {len(ceq_functions)} nonlinear equality constraints")

    def add_bounds(self, lb=None, ub=None):
        """
        添加变量边界约束

        参数:
            lb: 下界向量
            ub: 上界向量
        """
        if lb is not None:
            for i, lower in enumerate(lb, 1):
                if lower is not None:
                    self.model.x[i].setlb(lower)

        if ub is not None:
            for i, upper in enumerate(ub, 1):
                if upper is not None:
                    self.model.x[i].setub(upper)

        print("Added variable bounds")

    def set_objective(self, objective_function, sense='minimize'):
        """
        设置目标函数

        参数:
            objective_function: 目标函数
            sense: 'minimize' 或 'maximize'
        """
        if sense == 'minimize':
            self.model.obj = pyo.Objective(expr=objective_function(self.model), sense=pyo.minimize)
        else:
            self.model.obj = pyo.Objective(expr=objective_function(self.model), sense=pyo.maximize)

        print(f"Set objective to {sense}")

    def solve(self, solver_name='ipopt', options=None):
        """
        求解模型

        参数:
            solver_name: 求解器名称 ('ipopt', 'bonmin', 'couenne', etc.)
            options: 求解器选项字典
        """
        print(f"\nSolving with {solver_name} solver...")

        # 创建求解器
        self.solver = pyo.SolverFactory(solver_name)

        # 设置求解器选项
        if options:
            for key, value in options.items():
                self.solver.options[key] = value

        # 求解
        try:
            self.results = self.solver.solve(self.model, tee=False)

            # 检查求解状态
            if (self.results.solver.status == SolverStatus.ok) and \
                    (self.results.solver.termination_condition == TerminationCondition.optimal):
                print("✓ Optimal solution found!")
                return True
            else:
                print(f"⚠ Solver status: {self.results.solver.status}")
                print(f"⚠ Termination condition: {self.results.solver.termination_condition}")
                return False

        except Exception as e:
            print(f"✗ Solver error: {e}")
            return False

    def get_results(self):
        """获取求解结果"""
        if self.model is None:
            return None

        results = {}
        results['objective_value'] = pyo.value(self.model.obj)
        results['variables'] = {}

        for i in self.model.I:
            results['variables'][f'x{i}'] = pyo.value(self.model.x[i])

        return results

    def print_results(self):
        """打印求解结果"""
        results = self.get_results()
        if results:
            print("\n" + "=" * 50)
            print("SOLUTION RESULTS")
            print("=" * 50)
            print(f"Objective value: {results['objective_value']:.6f}")
            print("Variables:")
            for var_name, var_value in results['variables'].items():
                print(f"  {var_name} = {var_value:.6f}")
        else:
            print("No solution available")


def example_1_simple_quadratic():
    """
    示例1: 简单二次规划问题
    min f(x) = x₁² + x₂² - 2x₁ - 4x₂
    s.t. x₁ + x₂ ≤ 3
         x₁, x₂ ≥ 0
    """
    print("=" * 60)
    print("EXAMPLE 1: Simple Quadratic Programming")
    print("=" * 60)
    print("Minimize: f(x) = x₁² + x₂² - 2x₁ - 4x₂")
    print("Subject to: x₁ + x₂ ≤ 3")
    print("           x₁, x₂ ≥ 0")

    solver = NonlinearProgrammingSolver()

    # 创建模型
    model = solver.create_general_nlp_model(n_vars=2)

    # 定义目标函数
    def objective(model):
        return model.x[1] ** 2 + model.x[2] ** 2 - 2 * model.x[1] - 4 * model.x[2]

    solver.set_objective(objective, 'minimize')

    # 添加线性约束
    A = [[1, 1]]  # x₁ + x₂ ≤ 3
    b = [3]
    solver.add_linear_constraints(A=A, b=b)

    # 添加变量边界
    solver.add_bounds(lb=[0, 0], ub=[None, None])

    # 求解
    if solver.solve():
        solver.print_results()
        return solver.get_results()

    return None


def example_2_constrained_optimization():
    """
    示例2: 带非线性约束的优化问题
    min f(x) = x₁² + x₂²
    s.t. x₁² + x₂² ≥ 1  (转换为 -(x₁² + x₂² - 1) ≤ 0)
         x₁ + x₂ = 1
         -2 ≤ x₁, x₂ ≤ 2
    """
    print("\n" + "=" * 60)
    print("EXAMPLE 2: Nonlinear Constrained Optimization")
    print("=" * 60)
    print("Minimize: f(x) = x₁² + x₂²")
    print("Subject to: x₁² + x₂² ≥ 1")
    print("           x₁ + x₂ = 1")
    print("           -2 ≤ x₁, x₂ ≤ 2")

    solver = NonlinearProgrammingSolver()

    # 创建模型
    model = solver.create_general_nlp_model(n_vars=2)

    # 定义目标函数
    def objective(model):
        return model.x[1] ** 2 + model.x[2] ** 2

    solver.set_objective(objective, 'minimize')

    # 添加等式约束 x₁ + x₂ = 1
    Aeq = [[1, 1]]
    beq = [1]
    solver.add_linear_constraints(Aeq=Aeq, beq=beq)

    # 添加非线性不等式约束 x₁² + x₂² ≥ 1 → -(x₁² + x₂² - 1) ≤ 0
    def nonlinear_constraint(model):
        return -(model.x[1] ** 2 + model.x[2] ** 2 - 1)

    solver.add_nonlinear_constraints(c_functions=[nonlinear_constraint])

    # 添加变量边界
    solver.add_bounds(lb=[-2, -2], ub=[2, 2])

    # 求解
    if solver.solve():
        solver.print_results()
        return solver.get_results()

    return None


def example_3_rosenbrock_function():
    """
    示例3: Rosenbrock函数优化
    min f(x) = 100(x₂ - x₁²)² + (1 - x₁)²
    s.t. x₁² + x₂² ≤ 2
         -2 ≤ x₁, x₂ ≤ 2
    """
    print("\n" + "=" * 60)
    print("EXAMPLE 3: Rosenbrock Function Optimization")
    print("=" * 60)
    print("Minimize: f(x) = 100(x₂ - x₁²)² + (1 - x₁)²")
    print("Subject to: x₁² + x₂² ≤ 2")
    print("           -2 ≤ x₁, x₂ ≤ 2")

    solver = NonlinearProgrammingSolver()

    # 创建模型
    model = solver.create_general_nlp_model(n_vars=2)

    # 定义Rosenbrock目标函数
    def rosenbrock(model):
        return 100 * (model.x[2] - model.x[1] ** 2) ** 2 + (1 - model.x[1]) ** 2

    solver.set_objective(rosenbrock, 'minimize')

    # 添加非线性约束 x₁² + x₂² ≤ 2
    def circle_constraint(model):
        return model.x[1] ** 2 + model.x[2] ** 2 - 2

    solver.add_nonlinear_constraints(c_functions=[circle_constraint])

    # 添加变量边界
    solver.add_bounds(lb=[-2, -2], ub=[2, 2])

    # 设置初始点
    solver.model.x[1].set_value(0.5)
    solver.model.x[2].set_value(0.5)

    # 求解
    if solver.solve():
        solver.print_results()
        return solver.get_results()

    return None


def visualize_optimization_results(results_list, titles):
    """可视化优化结果"""
    if not results_list:
        return

    fig, axes = plt.subplots(1, len(results_list), figsize=(5 * len(results_list), 4))
    if len(results_list) == 1:
        axes = [axes]

    for i, (results, title) in enumerate(zip(results_list, titles)):
        if results is None:
            continue

        ax = axes[i]

        # 创建网格
        x1_range = np.linspace(-3, 3, 100)
        x2_range = np.linspace(-3, 3, 100)
        X1, X2 = np.meshgrid(x1_range, x2_range)

        # 根据不同例子绘制等高线
        if i == 0:  # 二次函数
            Z = X1 ** 2 + X2 ** 2 - 2 * X1 - 4 * X2
            ax.contour(X1, X2, Z, levels=20, alpha=0.6)
            # 绘制约束 x₁ + x₂ ≤ 3
            x1_line = np.linspace(0, 3, 100)
            x2_line = 3 - x1_line
            ax.plot(x1_line, x2_line, 'r-', linewidth=2, label='x₁ + x₂ ≤ 3')
            ax.fill_between(x1_line, 0, x2_line, alpha=0.2, color='blue')

        elif i == 1:  # 带圆约束
            Z = X1 ** 2 + X2 ** 2
            ax.contour(X1, X2, Z, levels=20, alpha=0.6)
            # 绘制约束
            theta = np.linspace(0, 2 * np.pi, 100)
            circle_x = np.cos(theta)
            circle_y = np.sin(theta)
            ax.plot(circle_x, circle_y, 'r-', linewidth=2, label='x₁² + x₂² = 1')
            line_x = np.linspace(-2, 2, 100)
            line_y = 1 - line_x
            ax.plot(line_x, line_y, 'g-', linewidth=2, label='x₁ + x₂ = 1')

        elif i == 2:  # Rosenbrock
            Z = 100 * (X2 - X1 ** 2) ** 2 + (1 - X1) ** 2
            ax.contour(X1, X2, Z, levels=np.logspace(0, 3, 20), alpha=0.6)
            # 绘制圆形约束
            theta = np.linspace(0, 2 * np.pi, 100)
            circle_x = np.sqrt(2) * np.cos(theta)
            circle_y = np.sqrt(2) * np.sin(theta)
            ax.plot(circle_x, circle_y, 'r-', linewidth=2, label='x₁² + x₂² ≤ 2')

        # 标记最优解
        x1_opt = results['variables']['x1']
        x2_opt = results['variables']['x2']
        ax.plot(x1_opt, x2_opt, 'ro', markersize=10,
                label=f'Optimal: ({x1_opt:.3f}, {x2_opt:.3f})')

        ax.set_xlim(-3, 3)
        ax.set_ylim(-3, 3)
        ax.set_xlabel('x₁')
        ax.set_ylabel('x₂')
        ax.set_title(title)
        ax.legend()
        ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()


def installation_guide():
    """Pyomo安装指南"""
    print("\n" + "=" * 60)
    print("PYOMO INSTALLATION GUIDE")
    print("=" * 60)
    print("To use Pyomo for nonlinear programming, install:")
    print()
    print("1. Basic Pyomo:")
    print("   pip install pyomo")
    print()
    print("2. IPOPT solver (recommended for NLP):")
    print("   conda install -c conda-forge ipopt")
    print("   # or")
    print("   pip install cyipopt")
    print()
    print("3. Alternative solvers:")
    print("   # For mixed-integer nonlinear programming")
    print("   conda install -c conda-forge bonmin")
    print("   conda install -c conda-forge couenne")
    print()
    print("4. Verify installation:")
    print("   pyomo help --solvers")


def main():
    """主函数"""
    print("PYOMO NONLINEAR PROGRAMMING SOLVER")
    print("=" * 60)
    print("Standard NLP Form:")
    print("  min f(x)")
    print("  s.t. A·x ≤ b")
    print("       Aeq·x = beq")
    print("       c(x) ≤ 0")
    print("       ceq(x) = 0")
    print("       lb ≤ x ≤ ub")
    print()

    try:
        # 运行示例
        results1 = example_1_simple_quadratic()
        results2 = example_2_constrained_optimization()
        results3 = example_3_rosenbrock_function()

        # 可视化结果
        results_list = [results1, results2, results3]
        titles = ['Quadratic Programming', 'Constrained Optimization', 'Rosenbrock Function']

        print("\nGenerating visualization...")
        visualize_optimization_results(results_list, titles)

        # 总结
        print("\n" + "=" * 60)
        print("SUMMARY")
        print("=" * 60)
        print("✓ Pyomo successfully solved all nonlinear programming problems")
        print("✓ IPOPT solver handled various constraint types effectively")
        print("✓ Both quadratic and highly nonlinear objectives were optimized")
        print("✓ Linear and nonlinear constraints were properly handled")

    except Exception as e:
        print(f"Error occurred: {e}")
        installation_guide()


if __name__ == "__main__":
    main()
```