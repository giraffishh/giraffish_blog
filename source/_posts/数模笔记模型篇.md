---
index_img: 'https://cdn.giraffish.me/blog/25-05-31-1748685017800.webp'
banner_img: 'https://cdn.giraffish.me/blog/25-05-31-1748684560329.webp'
title: æ•°æ¨¡ç¬”è®°æ¨¡å‹ç¯‡
categories:
  - å­¦ä¹ ç¬”è®°
tags:
  - æ•°å­¦å»ºæ¨¡
comments: true
abbrlink: 51e2c075
date: 2025-05-31 20:12:39
updated: 2025-06-25 21:49:01
---
## çº¿æ€§è§„åˆ’ï¼ˆLPï¼‰

### ä¸€èˆ¬å½¢å¼

![](https://cdn.giraffish.me/blog/25-05-31-1748681029505.png)

**å¯è¡Œè§£ï¼š** æ»¡è¶³çº¦æŸæ¡ä»¶ï¼ˆ4ï¼‰çš„è§£ $x = [x_1, \ldots, x_n]^T$ï¼Œç§°ä¸ºçº¿æ€§è§„åˆ’é—®é¢˜çš„å¯è¡Œè§£ï¼Œè€Œä½¿ç›®æ ‡å‡½æ•°ï¼ˆ3ï¼‰è¾¾åˆ°æœ€å¤§å€¼çš„å¯è¡Œè§£å«æœ€ä¼˜è§£ã€‚  

**å¯è¡ŒåŸŸï¼š** å¯è¡Œè§£æ„æˆçš„é›†åˆç§°ä¸ºé—®é¢˜çš„å¯è¡ŒåŸŸï¼Œè®°ä¸º $R$

ä½¿ç”¨ `scipy.optimize.linprog` è§£ LP çš„ä»£ç æ¨¡æ¿

> 25.6.25æ›´æ–°ï¼š`scipy.optimize.linprog`ç‹—éƒ½ä¸ç”¨ï¼Œç›´æ¥ç”¨PuLPåº“å¤ªé¦™äº†

```python
from scipy.optimize import linprog

# ç›®æ ‡å‡½æ•°ç³»æ•° cï¼ˆæ³¨æ„æ˜¯æœ€å°åŒ–ï¼‰
c = [cost1, cost2, ..., costn]  # è¦æ±‚æœ€å°åŒ– c^T x

# ä¸ç­‰å¼çº¦æŸï¼šAx â‰¤ b, è‹¥Ax â‰¥ båˆ™ä¸¤è¾¹åŒæ—¶å–è´Ÿå·âˆ’Ax â‰¤ âˆ’b
A = [
    [a11, a12, ..., a1n],
    [a21, a22, ..., a2n],
    ...
]
b = [b1, b2, ..., bm]

# ç­‰å¼çº¦æŸï¼šAeq x = beqï¼ˆå¯é€‰ï¼‰
A_eq = [
    [aeq11, aeq12, ..., aeq1n],
    ...
]
b_eq = [beq1, beq2, ...]

# å˜é‡èŒƒå›´ï¼šæ¯ä¸ªå˜é‡ x_i çš„ (min, max)
bounds = [(lb1, ub1), (lb2, ub2), ..., (lbn, ubn)]

# æ±‚è§£
res = linprog(c, A_ub=A, b_ub=b, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method="highs")

# è¾“å‡ºç»“æœ
if res.success:
    print("æœ€å°å€¼:", res.fun)
    print("æœ€ä¼˜è§£ x:", res.x)
else:
    print("æ±‚è§£å¤±è´¥:", res.message)
```

> è‹¥æ±‚æœ€å¤§å€¼å°±åœ¨ç›®æ ‡å‡½æ•°cå¤„åŠ è´Ÿå·
>
> ä¾‹å¦‚ï¼šæœ€å¤§åŒ–åˆ©æ¶¦ 40x + 30y â†’ æœ€å°åŒ– -40x -30y
> åˆ™ `c = [-40, -30]`

éçº¿æ€§çš„æœ‰æ—¶å€™ä¹Ÿå¯ä»¥è½¬åŒ–ä¸ºçº¿æ€§è§„åˆ’çš„é—®é¢˜

![](https://cdn.giraffish.me/blog/25-05-31-1748683411323.webp)

***

### ä¾‹é¢˜

å¸‚åœºä¸Šæœ‰ $n$ ç§èµ„äº§ $S_i$ï¼ˆ$i = 1, 2, \ldots, n$ï¼‰å¯ä»¥é€‰æ‹©ï¼Œç°ç”¨æ•°é¢ä¸º $M$ çš„ç›¸å½“å¤§çš„èµ„é‡‘ä½œä¸€ä¸ªæ—¶æœŸçš„æŠ•èµ„ã€‚è¿™ $n$ ç§èµ„äº§åœ¨è¿™ä¸€æ—¶æœŸå†…è´­ä¹° $S_i$ çš„å¹³å‡æ”¶ç›Šç‡ä¸º $r_i$ï¼Œé£é™©æŸå¤±ç‡ä¸º $q_i$ã€‚æŠ•èµ„è¶Šåˆ†æ•£ï¼Œæ€»çš„é£é™©è¶Šå°‘ï¼Œæ€»ä½“é£é™©å¯ç”¨æŠ•èµ„çš„ $S_i$ ä¸­æœ€å¤§çš„ä¸€ä¸ªé£é™©æ¥åº¦é‡ã€‚

è´­ä¹° $S_i$ æ—¶è¦ä»˜äº¤æ˜“è´¹ï¼Œè´¹ç‡ä¸º $p_i$ï¼Œå½“è´­ä¹°é¢ä¸è¶…è¿‡ç»™å®šå€¼ $u_i$ æ—¶ï¼Œäº¤æ˜“è´¹æŒ‰è´­ä¹° $u_i$ è®¡ç®—ã€‚å¦å¤–ï¼Œå‡å®šåŒæœŸé“¶è¡Œå­˜æ¬¾åˆ©ç‡æ˜¯ $r_0$ï¼ˆ$r_0 = 5\%$ï¼‰ï¼Œæ—¢æ— äº¤æ˜“è´¹åˆæ— é£é™©ã€‚

å·²çŸ¥ $n = 4$ æ—¶ç›¸å…³æ•°æ®å¦‚ä¸‹ï¼š

| èµ„äº§ $S_i$ | æ”¶ç›Šç‡ $r_i(\%)$ | é£é™©ç‡ $q_i(\%)$ | äº¤æ˜“è´¹ç‡ $p_i(\%)$ | äº¤æ˜“è´¹é˜ˆå€¼ $u_i$(å…ƒ) |
|------------|------------------|------------------|--------------------|-----------------------|
| $S_1$      | 28               | 2.5              | 1                  | 103                   |
| $S_2$      | 21               | 1.5              | 2                  | 198                   |
| $S_3$      | 23               | 5.5              | 4.5                | 52                    |
| $S_4$      | 25               | 2.6              | 6.5                | 40                    |

**æŠ•èµ„ç›®æ ‡** 
ç”¨ç»™å®šèµ„é‡‘ $M$ï¼Œæœ‰é€‰æ‹©åœ°è´­ä¹°è‹¥å¹²ç§èµ„äº§æˆ–å­˜é“¶è¡Œç”Ÿæ¯ï¼ˆæ— é£é™©åˆ©ç‡ $r_0=5\%$ï¼‰ï¼Œè¦æ±‚ï¼š

1. å‡€æ”¶ç›Šå°½å¯èƒ½å¤§
2. æ€»ä½“é£é™©ï¼ˆå®šä¹‰ä¸ºæ‰€æŠ•èµ„èµ„äº§ä¸­æœ€å¤§å•ä¸ªé£é™©ï¼‰å°½å¯èƒ½å°

### è§£ç­”

#### ç¬¦å·è§„å®š

| ç¬¦å· | è¯´æ˜ |
|------|------|
| $s_i$ | ç¬¬ $i$ ç§æŠ•èµ„é¡¹ç›®ï¼ˆ$i = 0,1,\ldots,n$ï¼‰ï¼Œå…¶ä¸­ $s_0$ è¡¨ç¤ºå­˜å…¥é“¶è¡Œ |
| $r_i$ | $s_i$ çš„å¹³å‡æ”¶ç›Šç‡ï¼ˆ$i = 0,\ldots,n$ï¼‰ |
| $p_i$ | $s_i$ çš„äº¤æ˜“è´¹ç‡ï¼ˆ$i = 0,\ldots,n$ï¼‰ï¼Œå…¶ä¸­ $p_0 = 0$ |
| $q_i$ | $s_i$ çš„é£é™©æŸå¤±ç‡ï¼ˆ$i = 0,\ldots,n$ï¼‰ï¼Œå…¶ä¸­ $q_0 = 0$ |
| $u_i$ | $s_i$ çš„äº¤æ˜“å®šé¢ï¼ˆ$i = 1,\ldots,n$ï¼‰ |
| $x_i$ | æŠ•èµ„é¡¹ç›® $s_i$ çš„èµ„é‡‘ï¼ˆ$i = 0,1,\ldots,n$ï¼‰ |
| $a$   | æŠ•èµ„é£é™©åº¦ |
| $Q$   | æ€»ä½“æ”¶ç›Š |

#### åŸºæœ¬å‡è®¾

* æŠ•èµ„è§„æ¨¡
   æŠ•èµ„æ•°é¢ $M$ ç›¸å½“å¤§ï¼Œä¸ºä¾¿äºè®¡ç®—ï¼Œè®¾ $M = 1$ï¼ˆå•ä½åŒ–å¤„ç†ï¼‰

* é£é™©åˆ†æ•£æ€§
   æŠ•èµ„è¶Šåˆ†æ•£ï¼Œæ€»é£é™©è¶Šå°

* é£é™©åº¦é‡
   æ€»ä½“é£é™©å®šä¹‰ä¸ºæ‰€æœ‰æŠ•èµ„é¡¹ç›® $s_i$ ä¸­æœ€å¤§çš„å•ä¸ªé£é™©ï¼Œå³ $\max(q_i x_i)$ï¼Œå…¶ä¸­ $x_i$ ä¸ºæŠ•èµ„æ¯”ä¾‹

* èµ„äº§ç‹¬ç«‹æ€§
   $n + 1$ ç§èµ„äº§ $s_i$ï¼ˆå«é“¶è¡Œå­˜æ¬¾ï¼‰ä¹‹é—´ç›¸äº’ç‹¬ç«‹

* å‚æ•°ç¨³å®šæ€§
   åœ¨æŠ•èµ„æœŸå†…ï¼Œå„èµ„äº§çš„å‚æ•°ä¸ºå®šå€¼ï¼Œä¸å—å…¶ä»–æ„å¤–å› ç´ å½±å“ï¼š 
   - æ”¶ç›Šç‡ $r_i$ 
   - äº¤æ˜“è´¹ç‡ $p_i$ 
   - é£é™©æŸå¤±ç‡ $q_i$ 

* æ”¶ç›Šä¸é£é™©çš„å†³å®šæ€§
   å‡€æ”¶ç›Šå’Œæ€»ä½“é£é™©ä»…ç”± $r_i, p_i, q_i$ å†³å®šï¼Œä¸å—å…¶ä»–å› ç´ å¹²æ‰°

#### æ¨¡å‹å…³é”®å®šä¹‰

* æ€»ä½“é£é™©åº¦é‡
   æ€»ä½“é£é™©å®šä¹‰ä¸ºæ‰€æŠ•èµ„èµ„äº§ä¸­æœ€å¤§å•é¡¹é£é™©ï¼š
   $$\max \{ q_i x_i \mid i = 1, 2, \ldots, n \}.$$

* äº¤æ˜“è´¹åˆ†æ®µå‡½æ•°
   è´­ä¹°èµ„äº§ $s_i$ ($i = 1, \ldots, n$) çš„äº¤æ˜“è´¹è®¡ç®—è§„åˆ™ï¼š 
   $$
   \text{äº¤æ˜“è´¹} = 
   \begin{cases} 
   p_i x_i, & x_i > u_i; \\ 
   p_i u_i, & x_i \leq u_i.
   \end{cases}
   $$
   > ç®€åŒ–å‡è®¾ï¼šç”±äº $u_i$ å’Œ $p_i u_i$ ç›¸å¯¹æ€»æŠ•èµ„ $M$ æå°ï¼Œå‡€æ”¶ç›Šå¯è¿‘ä¼¼ä¸º $(r_i - p_i)x_i$

* å¤šç›®æ ‡è§„åˆ’æ€§è´¨
   ç›®æ ‡å‡½æ•°éœ€åŒæ—¶æ»¡è¶³ï¼š 

   - å‡€æ”¶ç›Š $(r_i - p_i)x_i$ æœ€å¤§åŒ– 
   - æ€»ä½“é£é™© $\max(q_i x_i)$ æœ€å°åŒ– 
     ï¼ˆéœ€é€šè¿‡å¤šç›®æ ‡ä¼˜åŒ–æ–¹æ³•æ±‚è§£ï¼‰
     

**æ€»ç»“ä¸€ä¸‹ï¼š**
$$
\text{ç›®æ ‡å‡½æ•°}
\begin{cases} 
\max \sum\limits_{i=0}^n (r_i - p_i)x_i & \text{(æœ€å¤§åŒ–å‡€æ”¶ç›Š)} \\ 
\min \max \{q_i x_i\} & \text{(æœ€å°åŒ–æœ€å¤§å•é¡¹é£é™©)}
\end{cases}
$$

$$
\text{çº¦æŸæ¡ä»¶}
\begin{cases} 
\sum\limits_{i=0}^n (1 + p_i)x_i = M & \text{(æ€»èµ„é‡‘çº¦æŸ)} \\ 
x_i \geq 0, & i = 0,1,\cdots,n
\end{cases}
$$

#### å¤šç›®æ ‡è½¬å•ç›®æ ‡

**æ¨¡å‹ä¸€ï¼š** å›ºå®šé£é™©æ°´å¹³ä¸‹çš„æ”¶ç›Šä¼˜åŒ–æ¨¡å‹

é€šè¿‡å¼•å…¥é£é™©æ‰¿å—ç•Œé™ $a$ï¼Œå°†å¤šç›®æ ‡è§„åˆ’è½¬åŒ–ä¸º**å•ç›®æ ‡çº¿æ€§è§„åˆ’**ï¼š
- é™å®šæœ€å¤§é£é™©ï¼š$\max \frac{q_i x_i}{M} \leq a$
- å•ä¸€ä¼˜åŒ–ç›®æ ‡ï¼šæœ€å¤§åŒ–å‡€æ”¶ç›Š

**ç›®æ ‡å‡½æ•°** 
$$
\max \sum_{i=0}^n (r_i - p_i)x_i
$$

**çº¦æŸæ¡ä»¶** 
$$
\begin{cases}
\frac{q_i x_i}{M} \leq a, & i=1,\ldots,n \quad \text{(å•é¡¹é£é™©æ§åˆ¶)} \\
\sum\limits_{i=0}^n (1 + p_i)x_i = M, & \text{(èµ„é‡‘æ€»é‡çº¦æŸ)} \\
x_i \geq 0, & i=0,1,\ldots,n \quad \text{(éè´ŸæŠ•èµ„)}
\end{cases}
$$

***

**æ¨¡å‹äºŒï¼š** å›ºå®šæ”¶ç›Šä¸‹çš„é£é™©æœ€å°åŒ–

**ç›®æ ‡å‡½æ•°** 
$$
\min \{\max \{ q_i x_i \}\}
$$

**çº¦æŸæ¡ä»¶** 
$$
\begin{cases}
\sum\limits_{i=0}^n (r_i - p_i)x_i \geq k & \text{(æœ€ä½æ”¶ç›Šè¦æ±‚)} \\
\sum\limits_{i=0}^n (1 + p_i)x_i = M & \text{(èµ„é‡‘æ€»é‡çº¦æŸ)} \\
x_i \geq 0, & i=0,1,\ldots,n
\end{cases}
$$

***

**æ¨¡å‹ä¸‰ï¼š** é£é™©-æ”¶ç›ŠåŠ æƒä¼˜åŒ–

æŠ•èµ„è€…åœ¨æƒè¡¡èµ„äº§é£é™©å’Œé¢„æœŸæ”¶ç›Šä¸¤æ–¹é¢æ—¶ï¼Œå¸Œæœ›é€‰æ‹©ä¸€ä¸ªä»¤è‡ªå·±æ»¡æ„çš„æŠ•èµ„ç»„åˆã€‚å› æ­¤å¯¹é£é™©ã€æ”¶ç›Šåˆ†åˆ«èµ‹äºˆæƒé‡ $s$ï¼ˆ$0 < s \leq 1$ï¼‰å’Œ $(1-s)$ï¼Œ$s$ç§°ä¸ºæŠ•èµ„åå¥½ç³»æ•°

**ç›®æ ‡å‡½æ•°** 
$$
\min \left[ s \cdot \max \{ q_i x_i \} - (1-s) \sum\limits_{i=0}^n (r_i - p_i)x_i \right]
$$

**çº¦æŸæ¡ä»¶** 
$$
\begin{cases}
\sum\limits_{i=0}^n (1 + p_i)x_i = M \\
x_i \geq 0, & i=0,1,\ldots,n
\end{cases}
$$

## æ•´æ•°è§„åˆ’ï¼ˆILPï¼‰

### æ•´æ•°è§„åˆ’ç‰¹ç‚¹

åŸçº¿æ€§è§„åˆ’æœ‰æœ€ä¼˜è§£ï¼Œå½“è‡ªå˜é‡é™åˆ¶ä¸ºæ•´æ•°åï¼Œå…¶æ•´æ•°è§„åˆ’è§£å‡ºç°ä¸‹è¿°æƒ…å†µ

1. åŸçº¿æ€§è§„åˆ’æœ€ä¼˜è§£å…¨æ˜¯æ•´æ•°ï¼Œåˆ™æ•´æ•°è§„åˆ’æœ€ä¼˜è§£ä¸çº¿æ€§è§„åˆ’æœ€ä¼˜è§£ä¸€è‡´
2. æ•´æ•°è§„åˆ’æ— å¯è¡Œè§£
3. æœ‰å¯è¡Œè§£ï¼ˆå½“ç„¶å°±å­˜åœ¨æœ€ä¼˜è§£ï¼‰ï¼Œä½†æœ€ä¼˜è§£å€¼å˜å·®

> æ•´æ•°è§„åˆ’æœ€ä¼˜è§£ä¸èƒ½æŒ‰ç…§å®æ•°æœ€ä¼˜è§£ç®€å•å–æ•´è€Œè·å¾—ï¼Œå¯èƒ½ä¼šè¶…å‡ºå¯è¡ŒåŸŸ

**æ•´æ•°è§„åˆ’åˆ†ç±»:**

* çº¯æ•´æ•°è§„åˆ’ï¼šæ‰€æœ‰å†³ç­–å˜é‡è¦æ±‚å–éè´Ÿæ•´æ•°ï¼ˆè¿™æ—¶å¼•è¿›çš„æ¾å¼›å˜é‡å’Œå‰©ä½™å˜é‡å¯ä»¥ä¸è¦æ±‚å–æ•´æ•°ï¼‰
* å…¨æ•´æ•°è§„åˆ’ï¼šé™¤äº†æ‰€æœ‰å†³ç­–å˜é‡è¦æ±‚å–éè´Ÿæ•´æ•°å¤–ï¼Œç³»æ•°$a_{ij}$å’Œå¸¸æ•°$b_i$ä¹Ÿè¦æ±‚å–æ•´æ•°ï¼ˆè¿™æ—¶å¼•è¿›çš„æ¾å¼›å˜é‡å’Œå‰©ä½™å˜é‡ä¹Ÿå¿…é¡»æ˜¯æ•´æ•°ï¼‰
* æ··åˆæ•´æ•°è§„åˆ’ï¼šåªæœ‰ä¸€éƒ¨åˆ†çš„å†³ç­–å˜é‡è¦æ±‚å–éè´Ÿæ•´æ•°ï¼Œå¦ä¸€éƒ¨åˆ†å¯ä»¥å–éè´Ÿå®æ•°
* 0â€”1æ•´æ•°è§„åˆ’ï¼šæ‰€æœ‰å†³ç­–å˜é‡åªèƒ½å–0æˆ–1ä¸¤ä¸ªæ•´æ•°

> **æ¾å¼›å˜é‡:** $x_1 + x_2 \geq 10$ å¼•å…¥ $x_3$ â†’ $x_1 + x_2 + x_3 = 10$ï¼Œ$x_3 \geq 0$
> **å‰©ä½™å˜é‡:** $x_1 + x_2 \geq 10$ å¼•å…¥ $x_3$ â†’ $x_1 + x_2 - x_3 = 10$ï¼Œ$x_3 \leq 0$
> æ¾å¼›å˜é‡å’Œå‰©ä½™å˜é‡çš„ç›®çš„æ˜¯å°†**ä¸ç­‰å¼çº¦æŸ**è½¬åŒ–ä¸º**ç­‰å¼çº¦æŸ**

æ•´æ•°è§„åˆ’ä¸æ¾å¼›çš„çº¿æ€§è§„åˆ’çš„å…³ç³»ï¼š

* æ•´æ•°è§„åˆ’å¯è¡Œè§£æ˜¯æ¾å¼›é—®é¢˜å¯è¡ŒåŸŸä¸­çš„æ•´æ•°æ ¼ç‚¹æ¾å¼›é—®é¢˜æ— å¯è¡Œè§£ï¼Œåˆ™æ•´æ•°è§„åˆ’æ— å¯è¡Œè§£
* ILPæœ€ä¼˜å€¼å°äºæˆ–ç­‰äºæ¾å¼›é—®é¢˜çš„æœ€ä¼˜å€¼
* æ¾å¼›é—®é¢˜æœ€ä¼˜è§£æ»¡è¶³æ•´æ•°è¦æ±‚ï¼Œåˆ™è¯¥æœ€ä¼˜è§£ä¸ºæ•´æ•°è§„åˆ’æœ€ä¼˜è§£


### ä¸€èˆ¬å½¢å¼

$$
\max(\min) \, z = \sum_{j=1}^n c_j x_j
$$

$$
\begin{cases} 
\sum_{j=1}^n a_{ij} x_j \leq (=, \geq) b_i & (i = 1, 2, \ldots m) \\ 
x_j \geq 0, & x_j \text{ä¸ºæ•´æ•°} \, (j = 1, 2, \ldots n)
\end{cases}
$$

### åˆ†æ”¯å®šç•Œç®—æ³• (Deprecated)

1. ä¸è€ƒè™‘æ•´æ•°é™åˆ¶å…ˆæ±‚å‡ºç›¸åº”æ¾å¼›é—®é¢˜çš„æœ€ä¼˜è§£

è‹¥ä¸æ»¡è¶³æ•´æ•°æ¡ä»¶ï¼Œåˆ™ä»»é€‰ä¸€ä¸ªä¸æ»¡è¶³æ•´æ•°æ¡ä»¶çš„å˜é‡ $x_i^0$ æ¥æ„é€ æ–°çš„çº¦æŸæ·»åŠ åˆ°æ¾å¼›é—®é¢˜ä¸­å½¢æˆä¸¤ä¸ªå­é—®é¢˜ï¼š

$$
x_i \leq \left\lfloor x_i^0 \right\rfloor
$$
$$
x_i \geq \left\lfloor x_i^0 \right\rfloor + 1
$$

2. ç¼©å°çš„å¯è¡ŒåŸŸä¸­æ±‚è§£æ–°æ„é€ çš„çº¿æ€§è§„åˆ’çš„æœ€ä¼˜è§£ï¼Œå¹¶é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°å­é—®é¢˜æ— è§£æˆ–æœ‰æ•´æ•°æœ€ä¼˜è§£ï¼ˆè¢«æŸ¥æ¸…ï¼‰

**ç¤ºä¾‹:**

$$
\max z = 3x_1 + 2x_2
$$

$$
\begin{cases} 
2x_1 + 3x_2 \leq 14 \\
2x_1 + x_2 \leq 9 \\ 
x_1, x_2 \geq 0 
\end{cases}
$$

```python
import numpy as np
from scipy.optimize import linprog
import matplotlib.pyplot as plt
from collections import deque


class BranchAndBoundSolver:
    """åˆ†æ”¯å®šç•Œæ³•æ±‚è§£å™¨ç±»"""

    def __init__(self):
        """åˆå§‹åŒ–æ±‚è§£å™¨"""
        self.best_solution = None  # æœ€ä¼˜è§£
        self.best_value = float('-inf')  # æœ€ä¼˜ç›®æ ‡å‡½æ•°å€¼
        self.nodes_explored = 0  # å·²æ¢ç´¢èŠ‚ç‚¹æ•°

    def solve_lp_relaxation(self, c, A_ub, b_ub, bounds):
        """
        æ±‚è§£çº¿æ€§è§„åˆ’æ¾å¼›é—®é¢˜
        å‚æ•°:
            c: ç›®æ ‡å‡½æ•°ç³»æ•°
            A_ub: ä¸ç­‰å¼çº¦æŸç³»æ•°çŸ©é˜µ
            b_ub: ä¸ç­‰å¼çº¦æŸå³ç«¯å‘é‡
            bounds: å˜é‡è¾¹ç•Œ
        è¿”å›:
            ç›®æ ‡å‡½æ•°å€¼, è§£å‘é‡
        """
        # scipyæ±‚æœ€å°å€¼ï¼Œç›®æ ‡å‡½æ•°ç³»æ•°å–è´Ÿæ•°è½¬æ¢ä¸ºæœ€å¤§å€¼é—®é¢˜
        result = linprog(-c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')

        if result.success:
            return -result.fun, result.x  # è¿”å›æœ€å¤§å€¼å’Œè§£
        else:
            return None, None

    def is_integer_solution(self, x, tolerance=1e-6):
        """æ£€æŸ¥è§£æ˜¯å¦ä¸ºæ•´æ•°è§£"""
        return all(abs(xi - round(xi)) < tolerance for xi in x)

    def find_fractional_variable(self, x, tolerance=1e-6):
        """æ‰¾åˆ°ç¬¬ä¸€ä¸ªéæ•´æ•°å˜é‡çš„ç´¢å¼•"""
        for i, xi in enumerate(x):
            if abs(xi - round(xi)) >= tolerance:
                return i
        return None

    def solve(self, c, A_ub, b_ub, initial_bounds):
        """
        ä¸»æ±‚è§£å‡½æ•° - åˆ†æ”¯å®šç•Œæ³•
        å‚æ•°:
            c: ç›®æ ‡å‡½æ•°ç³»æ•°
            A_ub: çº¦æŸçŸ©é˜µ
            b_ub: çº¦æŸå³ç«¯å‘é‡
            initial_bounds: åˆå§‹å˜é‡è¾¹ç•Œ
        """
        # ç”¨é˜Ÿåˆ—å­˜å‚¨å¾…å¤„ç†çš„èŠ‚ç‚¹ (è¾¹ç•Œ, æ·±åº¦)
        queue = deque([(initial_bounds, 0)])

        print("å¼€å§‹åˆ†æ”¯å®šç•Œæ³•æ±‚è§£...")
        print("=" * 50)

        while queue:
            current_bounds, depth = queue.popleft()
            self.nodes_explored += 1

            print(f"\nèŠ‚ç‚¹ {self.nodes_explored}:")
            print(f"è¾¹ç•Œ: x1âˆˆ{current_bounds[0]}, x2âˆˆ{current_bounds[1]}")

            # æ±‚è§£å½“å‰èŠ‚ç‚¹çš„LPæ¾å¼›
            obj_value, solution = self.solve_lp_relaxation(c, A_ub, b_ub, current_bounds)

            if obj_value is None:
                print("  æ— å¯è¡Œè§£")
                continue

            print(f"  LPè§£: x1={solution[0]:.3f}, x2={solution[1]:.3f}, z={obj_value:.3f}")

            # å‰ªæï¼šå¦‚æœä¸Šç•Œä¸èƒ½æ”¹è¿›å½“å‰æœ€ä¼˜è§£
            if obj_value <= self.best_value:
                print(f"  å‰ªæ: {obj_value:.3f} â‰¤ {self.best_value}")
                continue

            # æ£€æŸ¥æ˜¯å¦ä¸ºæ•´æ•°è§£
            if self.is_integer_solution(solution):
                print("  *** æ‰¾åˆ°æ•´æ•°è§£! ***")
                if obj_value > self.best_value:
                    self.best_value = obj_value
                    self.best_solution = solution.copy()
                    print(f"  *** æ›´æ–°æœ€ä¼˜è§£: z={obj_value} ***")
                continue

            # åˆ†æ”¯ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªéæ•´æ•°å˜é‡
            branch_var = self.find_fractional_variable(solution)
            if branch_var is not None:
                branch_value = solution[branch_var]
                print(f"  åˆ†æ”¯å˜é‡: x{branch_var + 1}={branch_value:.3f}")

                # åˆ›å»ºå·¦å³ä¸¤ä¸ªå­é—®é¢˜
                left_bounds = [list(bound) if isinstance(bound, tuple) else bound for bound in current_bounds]
                right_bounds = [list(bound) if isinstance(bound, tuple) else bound for bound in current_bounds]

                # å·¦åˆ†æ”¯: x[branch_var] <= floor(branch_value)
                left_bounds[branch_var] = (left_bounds[branch_var][0], int(branch_value))
                # å³åˆ†æ”¯: x[branch_var] >= ceil(branch_value)
                right_bounds[branch_var] = (int(branch_value) + 1, right_bounds[branch_var][1])

                # æ·»åŠ å­é—®é¢˜åˆ°é˜Ÿåˆ—
                queue.append((left_bounds, depth + 1))
                queue.append((right_bounds, depth + 1))

        # è¾“å‡ºæœ€ç»ˆç»“æœ
        print("\n" + "=" * 50)
        print("æ±‚è§£å®Œæˆ!")
        print(f"æ¢ç´¢èŠ‚ç‚¹æ•°: {self.nodes_explored}")

        if self.best_solution is not None:
            print(f"æœ€ä¼˜è§£: x1={int(self.best_solution[0])}, x2={int(self.best_solution[1])}")
            print(f"æœ€ä¼˜å€¼: z={self.best_value}")
        else:
            print("æœªæ‰¾åˆ°å¯è¡Œè§£")

    def visualize_problem(self, c, A_ub, b_ub):
        """
        å¯è§†åŒ–é—®é¢˜çš„å¯è¡ŒåŸŸå’Œè§£
        å‚æ•°:
            c: ç›®æ ‡å‡½æ•°ç³»æ•°
            A_ub: çº¦æŸçŸ©é˜µ
            b_ub: çº¦æŸå³ç«¯å‘é‡
        """
        # åˆ›å»ºå›¾å½¢
        plt.figure(figsize=(10, 8))

        # å®šä¹‰x1çš„èŒƒå›´
        x1 = np.linspace(0, 6, 100)

        # ç»˜åˆ¶çº¦æŸçº¿
        # çº¦æŸ1: 2x1 + 3x2 <= 14
        x2_1 = (14 - 2 * x1) / 3
        plt.plot(x1, x2_1, 'b-', label='2xâ‚ + 3xâ‚‚ â‰¤ 14', linewidth=2)

        # çº¦æŸ2: 2x1 + x2 <= 9
        x2_2 = 9 - 2 * x1
        plt.plot(x1, x2_2, 'r-', label='2xâ‚ + xâ‚‚ â‰¤ 9', linewidth=2)

        # å¡«å……å¯è¡ŒåŸŸ
        x1_fill = np.linspace(0, 4.5, 100)
        x2_fill1 = np.minimum((14 - 2 * x1_fill) / 3, 9 - 2 * x1_fill)
        x2_fill2 = np.zeros_like(x1_fill)
        plt.fill_between(x1_fill, x2_fill2, np.maximum(x2_fill1, 0),
                         alpha=0.3, color='lightblue', label='Feasible Region')

        # ç»˜åˆ¶ç›®æ ‡å‡½æ•°ç­‰å€¼çº¿
        X1, X2 = np.meshgrid(np.linspace(0, 6, 50), np.linspace(0, 6, 50))
        Z = 3 * X1 + 2 * X2
        contours = plt.contour(X1, X2, Z, levels=8, colors='green', alpha=0.6)
        plt.clabel(contours, inline=True, fontsize=8)

        # æ ‡è®°æ‰€æœ‰æ•´æ•°ç‚¹
        for i in range(6):
            for j in range(6):
                if 2 * i + 3 * j <= 14 and 2 * i + j <= 9 and i >= 0 and j >= 0:
                    plt.plot(i, j, 'ko', markersize=6)

        # æ ‡è®°æœ€ä¼˜è§£
        if self.best_solution is not None:
            x1_opt, x2_opt = int(self.best_solution[0]), int(self.best_solution[1])
            plt.plot(x1_opt, x2_opt, 'ro', markersize=12,
                     label=f'Optimal Solution ({x1_opt}, {x2_opt})')

        # è®¾ç½®å›¾å½¢å±æ€§
        plt.xlim(0, 6)
        plt.ylim(0, 6)
        plt.xlabel('xâ‚')
        plt.ylabel('xâ‚‚')
        plt.title('Integer Linear Programming Problem\nmax z = 3xâ‚ + 2xâ‚‚')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()


def main():
    """ä¸»å‡½æ•° - å®šä¹‰é—®é¢˜å¹¶æ±‚è§£"""

    # 1. å®šä¹‰é—®é¢˜å‚æ•°
    print("çº¿æ€§æ•´æ•°è§„åˆ’é—®é¢˜:")
    print("ç›®æ ‡å‡½æ•°: max z = 3xâ‚ + 2xâ‚‚")
    print("çº¦æŸæ¡ä»¶:")
    print("  2xâ‚ + 3xâ‚‚ â‰¤ 14")
    print("  2xâ‚ + xâ‚‚ â‰¤ 9")
    print("  xâ‚, xâ‚‚ â‰¥ 0 ä¸”ä¸ºæ•´æ•°")

    # ç›®æ ‡å‡½æ•°ç³»æ•°
    c = np.array([3, 2])

    # çº¦æŸçŸ©é˜µå’Œå³ç«¯å‘é‡
    A_ub = np.array([
        [2, 3],  # ç¬¬ä¸€ä¸ªçº¦æŸ: 2xâ‚ + 3xâ‚‚ â‰¤ 14
        [2, 1]  # ç¬¬äºŒä¸ªçº¦æŸ: 2xâ‚ + xâ‚‚ â‰¤ 9
    ])
    b_ub = np.array([14, 9])

    # å˜é‡è¾¹ç•Œ (ä¸‹ç•Œ, ä¸Šç•Œ)
    initial_bounds = [(0, 10), (0, 10)]

    # 2. åˆ›å»ºæ±‚è§£å™¨å¹¶æ±‚è§£
    solver = BranchAndBoundSolver()
    solver.solve(c, A_ub, b_ub, initial_bounds)

    # 3. å¯è§†åŒ–ç»“æœ
    solver.visualize_problem(c, A_ub, b_ub)

    # 4. éªŒè¯è§£çš„æ­£ç¡®æ€§
    if solver.best_solution is not None:
        x1, x2 = int(solver.best_solution[0]), int(solver.best_solution[1])
        print(f"\nè§£çš„éªŒè¯:")

        # æ£€æŸ¥çº¦æŸæ¡ä»¶
        constraint1 = 2 * x1 + 3 * x2
        constraint2 = 2 * x1 + x2
        objective = 3 * x1 + 2 * x2

        print(f"çº¦æŸ1: 2Ã—{x1} + 3Ã—{x2} = {constraint1} â‰¤ 14 âœ“" if constraint1 <= 14 else "çº¦æŸ1è¿å!")
        print(f"çº¦æŸ2: 2Ã—{x1} + 1Ã—{x2} = {constraint2} â‰¤ 9 âœ“" if constraint2 <= 9 else "çº¦æŸ2è¿å!")
        print(f"ç›®æ ‡å‡½æ•°: 3Ã—{x1} + 2Ã—{x2} = {objective}")

        # 5. ä¸LPæ¾å¼›è§£æ¯”è¾ƒ
        print(f"\nä¸LPæ¾å¼›è§£çš„æ¯”è¾ƒ:")
        result = linprog(-c, A_ub=A_ub, b_ub=b_ub, bounds=[(0, None), (0, None)], method='highs')
        if result.success:
            lp_solution = result.x
            lp_value = -result.fun
            print(f"LPæ¾å¼›è§£: xâ‚={lp_solution[0]:.3f}, xâ‚‚={lp_solution[1]:.3f}")
            print(f"LPæ¾å¼›å€¼: z={lp_value:.3f}")
            print(f"æ•´æ•°è§£å€¼: z={objective}")
            print(f"æœ€ä¼˜æ€§é—´éš™: {lp_value - objective:.3f}")


if __name__ == "__main__":
    main()
```

è¾“å‡ºï¼š
```
çº¿æ€§æ•´æ•°è§„åˆ’é—®é¢˜:
ç›®æ ‡å‡½æ•°: max z = 3xâ‚ + 2xâ‚‚
çº¦æŸæ¡ä»¶:
  2xâ‚ + 3xâ‚‚ â‰¤ 14
  2xâ‚ + xâ‚‚ â‰¤ 9
  xâ‚, xâ‚‚ â‰¥ 0 ä¸”ä¸ºæ•´æ•°
å¼€å§‹åˆ†æ”¯å®šç•Œæ³•æ±‚è§£...
==================================================

èŠ‚ç‚¹ 1:
è¾¹ç•Œ: x1âˆˆ(0, 10), x2âˆˆ(0, 10)
  LPè§£: x1=3.250, x2=2.500, z=14.750
  åˆ†æ”¯å˜é‡: x1=3.250

èŠ‚ç‚¹ 2:
è¾¹ç•Œ: x1âˆˆ(0, 3), x2âˆˆ[0, 10]
  LPè§£: x1=3.000, x2=2.667, z=14.333
  åˆ†æ”¯å˜é‡: x2=2.667

èŠ‚ç‚¹ 3:
è¾¹ç•Œ: x1âˆˆ(4, 10), x2âˆˆ[0, 10]
  LPè§£: x1=4.000, x2=1.000, z=14.000
  *** æ‰¾åˆ°æ•´æ•°è§£! ***
  *** æ›´æ–°æœ€ä¼˜è§£: z=14.0 ***

èŠ‚ç‚¹ 4:
è¾¹ç•Œ: x1âˆˆ[0, 3], x2âˆˆ(0, 2)
  LPè§£: x1=3.000, x2=2.000, z=13.000
  å‰ªæ: 13.000 â‰¤ 14.0

èŠ‚ç‚¹ 5:
è¾¹ç•Œ: x1âˆˆ[0, 3], x2âˆˆ(3, 10)
  LPè§£: x1=2.500, x2=3.000, z=13.500
  å‰ªæ: 13.500 â‰¤ 14.0

==================================================
æ±‚è§£å®Œæˆ!
æ¢ç´¢èŠ‚ç‚¹æ•°: 5
æœ€ä¼˜è§£: x1=4, x2=1
æœ€ä¼˜å€¼: z=14.0

è§£çš„éªŒè¯:
çº¦æŸ1: 2Ã—4 + 3Ã—1 = 11 â‰¤ 14 âœ“
çº¦æŸ2: 2Ã—4 + 1Ã—1 = 9 â‰¤ 9 âœ“
ç›®æ ‡å‡½æ•°: 3Ã—4 + 2Ã—1 = 14

ä¸LPæ¾å¼›è§£çš„æ¯”è¾ƒ:
LPæ¾å¼›è§£: xâ‚=3.250, xâ‚‚=2.500
LPæ¾å¼›å€¼: z=14.750
æ•´æ•°è§£å€¼: z=14
æœ€ä¼˜æ€§é—´éš™: 0.750
```

![](https://cdn.giraffish.me/blog/25-06-16-1750045145904.webp)

### PuLPåº“

PuLPæ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„Pythonåº“ï¼Œä¸“é—¨ç”¨äºè§£å†³çº¿æ€§è§„åˆ’ã€æ•´æ•°è§„åˆ’å’Œæ··åˆæ•´æ•°è§„åˆ’é—®é¢˜

**ç¤ºä¾‹:**
```python
import pulp


def solve_integer_programming_with_pulp():
    """
    ä½¿ç”¨PuLPæ±‚è§£æ•´æ•°çº¿æ€§è§„åˆ’é—®é¢˜

    é—®é¢˜æè¿°:
    æœ€å¤§åŒ–: z = 3xâ‚ + 2xâ‚‚
    çº¦æŸæ¡ä»¶:
        2xâ‚ + 3xâ‚‚ â‰¤ 14
        2xâ‚ + xâ‚‚ â‰¤ 9
        xâ‚, xâ‚‚ â‰¥ 0 ä¸”ä¸ºæ•´æ•°
    """

    # æ­¥éª¤1: åˆ›å»ºé—®é¢˜å®ä¾‹
    prob = pulp.LpProblem("Integer_Linear_Programming", pulp.LpMaximize)

    # æ­¥éª¤2: å®šä¹‰å†³ç­–å˜é‡ï¼ˆæ•´æ•°å˜é‡ï¼‰
    x1 = pulp.LpVariable("x1", lowBound=0, cat='Integer')
    x2 = pulp.LpVariable("x2", lowBound=0, cat='Integer')

    # æ­¥éª¤3: æ·»åŠ ç›®æ ‡å‡½æ•°
    prob += 3 * x1 + 2 * x2, "Objective_Function"

    # æ­¥éª¤4: æ·»åŠ çº¦æŸæ¡ä»¶
    prob += 2 * x1 + 3 * x2 <= 14, "Material_Constraint"
    prob += 2 * x1 + x2 <= 9, "Time_Constraint"

    # æ­¥éª¤5: æ±‚è§£é—®é¢˜
    print("Solving the problem...")
    prob.solve(pulp.PULP_CBC_CMD(msg=0))  # msg=0 éšè—æ±‚è§£å™¨è¯¦ç»†è¾“å‡º

    # æ­¥éª¤6: æ£€æŸ¥æ±‚è§£çŠ¶æ€
    print(f"Status: {pulp.LpStatus[prob.status]}")

    # æ­¥éª¤7: è¾“å‡ºç»“æœ
    if prob.status == pulp.LpStatusOptimal:
        print("\nOptimal Solution Found!")
        print(f"xâ‚ = {int(x1.varValue)}")
        print(f"xâ‚‚ = {int(x2.varValue)}")
        print(f"Maximum objective value z = {int(pulp.value(prob.objective))}")

        # éªŒè¯çº¦æŸæ¡ä»¶
        print("\nConstraint Verification:")
        x1_val = int(x1.varValue)
        x2_val = int(x2.varValue)

        constraint1_value = 2 * x1_val + 3 * x2_val
        constraint2_value = 2 * x1_val + x2_val

        print(f"Constraint 1: 2Ã—{x1_val} + 3Ã—{x2_val} = {constraint1_value} â‰¤ 14 âœ“")
        print(f"Constraint 2: 2Ã—{x1_val} + 1Ã—{x2_val} = {constraint2_value} â‰¤ 9 âœ“")

        return x1_val, x2_val, int(pulp.value(prob.objective))
    else:
        print("No optimal solution found!")
        return None

def main():
    solve_integer_programming_with_pulp()

if __name__ == "__main__":
    main()
```

## éçº¿æ€§è§„åˆ’ï¼ˆNPï¼‰

### ä¸€èˆ¬å½¢å¼

$$
\min f(x)
$$

$$
\begin{cases}
A \cdot x \leq b \\
Aeq \cdot x = beq \\
c(x) \leq 0 \\
ceq(x) = 0 \\
lb \leq x \leq ub
\end{cases}
$$


å…¶ä¸­ï¼š
- $f(x)$ æ˜¯æ ‡é‡ç›®æ ‡å‡½æ•°
- $A$, $b$, $Aeq$, $beq$ æ˜¯çº¿æ€§çº¦æŸçš„çŸ©é˜µå’Œå‘é‡
- $c(x)$, $ceq(x)$ æ˜¯éçº¿æ€§çº¦æŸå‡½æ•°
- $lb$, $ub$ æ˜¯å˜é‡çš„ä¸‹ç•Œå’Œä¸Šç•Œ

### Pyomoåº“

[Pyomo](https://pyomo.readthedocs.io/en/stable/)ä½œä¸ºä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„Pythonä¼˜åŒ–å»ºæ¨¡è¯­è¨€ï¼Œèƒ½å¤Ÿå¤„ç†å¹¿æ³›çš„æ•°å­¦è§„åˆ’é—®é¢˜

å…·ä½“åŒ…æ‹¬ï¼š

**çº¿æ€§è§„åˆ’é—®é¢˜**

- æ ‡å‡†çº¿æ€§è§„åˆ’ï¼ˆLPï¼‰
- æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ï¼ˆMILPï¼‰

**éçº¿æ€§è§„åˆ’é—®é¢˜**

- éçº¿æ€§è§„åˆ’ï¼ˆNLPï¼‰
- æ··åˆæ•´æ•°éçº¿æ€§è§„åˆ’ï¼ˆMINLPï¼‰
- æ··åˆæ•´æ•°äºŒæ¬¡è§„åˆ’ï¼ˆMIQPï¼‰

**ç‰¹æ®Šé—®é¢˜ç±»å‹**

- äºŒæ¬¡è§„åˆ’ï¼ˆQPï¼‰
- éšæœºè§„åˆ’
- åŒå±‚è§„åˆ’é—®é¢˜
- å¹¿ä¹‰æå–è§„åˆ’
- å¸¦å¹³è¡¡çº¦æŸçš„æ•°å­¦è§„åˆ’
- å¾®åˆ†ä»£æ•°æ–¹ç¨‹ä¼˜åŒ–é—®é¢˜

**å®‰è£…:**

```cmd
pip install pyomo
conda install -c conda-forge ipopt
```

> Pyomoå’Œæ±‚è§£å™¨çš„å®‰è£…å»ºè®®ç”¨condaè€Œä¸æ˜¯æ™®é€šçš„è™šæ‹Ÿç¯å¢ƒï¼Œä¸ç„¶ä¼šé‡åˆ°å¥‡å¦™bugï¼ˆ

**ç¤ºä¾‹ä»£ç :**

> `unified_regressor.py`

```python
import pyomo.environ as pyo
import numpy as np
import matplotlib.pyplot as plt
from pyomo.opt import SolverStatus, TerminationCondition
import warnings

warnings.filterwarnings('ignore')

# English font setup for all plots
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.size'] = 10


class OptimizationSolver:

    def __init__(self, name="Problem"):
        self.model = None
        self.solver = None
        self.results = None
        self.name = name
        self.problem_type = "LP"
        self.var_names = []
        self.var_types = []
        self.constraint_counter = 0
        self.has_integer_vars = False
        self.has_continuous_vars = False
        self.has_quadratic_terms = False
        self.has_nonlinear_terms = False

    def create_model(self, n_vars, var_names=None, var_types=None, lb=None, ub=None):
        """Create optimization model with mixed variable types"""
        self.model = pyo.ConcreteModel(self.name)
        self.model.I = pyo.RangeSet(1, n_vars)

        # Handle variable names
        if var_names is None:
            self.var_names = [f"x{i}" for i in range(1, n_vars + 1)]
        else:
            self.var_names = list(var_names[:n_vars])
            while len(self.var_names) < n_vars:
                self.var_names.append(f"x{len(self.var_names) + 1}")

        # Handle variable types
        if var_types is None:
            self.var_types = ['continuous'] * n_vars
        elif isinstance(var_types, str):
            self.var_types = [var_types] * n_vars
        else:
            self.var_types = list(var_types[:n_vars])
            while len(self.var_types) < n_vars:
                self.var_types.append('continuous')

        # Track variable types
        self.has_integer_vars = any(vtype in ['integer', 'binary'] for vtype in self.var_types)
        self.has_continuous_vars = any(vtype == 'continuous' for vtype in self.var_types)

        # Create variables with individual domains
        self.model.x = pyo.Var(self.model.I)

        for i, var_type in enumerate(self.var_types, 1):
            if var_type == 'continuous':
                self.model.x[i].domain = pyo.Reals
            elif var_type == 'integer':
                self.model.x[i].domain = pyo.Integers
            elif var_type == 'binary':
                self.model.x[i].domain = pyo.Binary
            else:
                self.model.x[i].domain = pyo.Reals

        # Set bounds with safety for nonlinear functions
        if lb is not None:
            if isinstance(lb, (int, float)):
                lb = [lb] * n_vars
            for i, lower in enumerate(lb, 1):
                if lower is not None and i <= n_vars:
                    # Safe bounds for sqrt and other nonlinear functions
                    safe_lower = max(lower, 1e-6) if lower >= 0 else lower
                    self.model.x[i].setlb(safe_lower)

        if ub is not None:
            if isinstance(ub, (int, float)):
                ub = [ub] * n_vars
            for i, upper in enumerate(ub, 1):
                if upper is not None and i <= n_vars:
                    self.model.x[i].setub(upper)

        return self

    def set_objective(self, objective_func, sense='minimize'):
        """Set objective function with type detection"""
        if sense.lower() in ['minimize', 'min']:
            self.model.obj = pyo.Objective(expr=objective_func(self.model), sense=pyo.minimize)
        else:
            self.model.obj = pyo.Objective(expr=objective_func(self.model), sense=pyo.maximize)

        self._detect_problem_type()
        return self

    def _detect_problem_type(self):
        """Detect problem type based on objective and variables"""
        self.has_quadratic_terms = False
        self.has_nonlinear_terms = False

        try:
            obj_str = str(self.model.obj.expr).lower()

            # Check for quadratic terms
            import re
            if (re.search(r'x\[\d+\]\*\*2', obj_str) or
                    re.search(r'x\[\d+\]\s*\*\s*x\[\d+\]', obj_str)):
                self.has_quadratic_terms = True

            # Check for nonlinear terms (sqrt, exp, log, higher powers)
            nonlinear_keywords = ['exp', 'log', 'sin', 'cos', 'sqrt']
            higher_powers = [f'**{i}' for i in range(3, 10)] + ['**0.5', '**1.5']

            if (any(keyword in obj_str for keyword in nonlinear_keywords) or
                    any(power in obj_str for power in higher_powers)):
                self.has_nonlinear_terms = True

        except:
            pass

        # Determine problem type
        if self.has_integer_vars and self.has_continuous_vars:
            # Mixed integer problem
            if self.has_nonlinear_terms:
                self.problem_type = "MINLP"
            elif self.has_quadratic_terms:
                self.problem_type = "MIQP"
            else:
                self.problem_type = "MILP"
        elif self.has_integer_vars:
            # Pure integer problem
            if self.has_nonlinear_terms:
                self.problem_type = "INLP"
            elif self.has_quadratic_terms:
                self.problem_type = "IQP"
            else:
                self.problem_type = "ILP"
        else:
            # Pure continuous problem
            if self.has_nonlinear_terms:
                self.problem_type = "NLP"
            elif self.has_quadratic_terms:
                self.problem_type = "QP"
            else:
                self.problem_type = "LP"

    def add_constraint(self, constraint_func, sense='<=', name=None):
        """Add single constraint"""
        self.constraint_counter += 1
        if name is None:
            name = f"constraint_{self.constraint_counter}"

        if sense == '<=':
            expr = constraint_func(self.model) <= 0
        elif sense == '>=':
            expr = constraint_func(self.model) >= 0
        else:  # '='
            expr = constraint_func(self.model) == 0

        setattr(self.model, name, pyo.Constraint(expr=expr))
        return self

    def add_linear_constraints(self, A, b, sense='<='):
        """Add multiple linear constraints"""
        A = np.array(A)
        b = np.array(b)

        if A.ndim == 1:
            A = A.reshape(1, -1)

        self.constraint_counter += 1
        constraint_name = f'linear_constraints_{self.constraint_counter}'

        if sense == '<=':
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) <= b[i - 1]
        elif sense == '>=':
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) >= b[i - 1]
        else:  # '='
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) == b[i - 1]

        setattr(self.model, constraint_name,
                pyo.Constraint(pyo.RangeSet(1, len(b)), rule=rule))

        return self

    def solve(self, solver=None, options=None, verbose=False):
        """Solve optimization problem"""
        if self.model is None:
            print("âŒ No model created!")
            return False

        # Auto-select solver
        if solver is None:
            if self.problem_type in ["LP", "QP", "NLP"]:
                solver = "ipopt" if self.problem_type == "NLP" else "gurobi"
            else:
                solver = "gurobi" if pyo.SolverFactory('gurobi').available() else "ipopt"

        if not pyo.SolverFactory(solver).available():
            print(f"âŒ Solver {solver} not available!")
            return False

        # Create solver
        self.solver = pyo.SolverFactory(solver)

        # Set solver options
        if solver == 'ipopt':
            clean_options = {
                'print_level': 0,  # Silent IPOPT
                'max_iter': 3000,
                'tol': 1e-6,
                'linear_solver': 'mumps'
            }
            if options:
                clean_options.update(options)

            for key, value in clean_options.items():
                self.solver.options[key] = value
        elif options:
            for key, value in options.items():
                self.solver.options[key] = value

        # Set safe initial point for nonlinear problems
        if self.has_nonlinear_terms:
            try:
                for i in self.model.I:
                    if self.model.x[i].value is None:
                        lb = self.model.x[i].lb if self.model.x[i].lb is not None else 0
                        ub = self.model.x[i].ub if self.model.x[i].ub is not None else 10
                        initial_val = max((lb + ub) / 2, 0.1)
                        self.model.x[i].set_value(initial_val)
            except:
                pass

        # Solve
        try:
            self.results = self.solver.solve(self.model, tee=verbose)

            if (self.results.solver.status == SolverStatus.ok and
                    self.results.solver.termination_condition in [TerminationCondition.optimal,
                                                                  TerminationCondition.locallyOptimal,
                                                                  TerminationCondition.feasible]):
                return True
            else:
                return False

        except:
            return False

    def get_solution(self):
        """Get solution information"""
        if not self.results:
            return None

        try:
            solution = {
                'objective_value': pyo.value(self.model.obj),
                'variables': {},
                'variable_types': {},
                'problem_type': self.problem_type,
                'solver_status': str(self.results.solver.status),
                'termination_condition': str(self.results.solver.termination_condition),
                'has_mixed_variables': self.has_integer_vars and self.has_continuous_vars
            }

            for i in self.model.I:
                var_name = self.var_names[i - 1]
                var_type = self.var_types[i - 1]
                value = pyo.value(self.model.x[i])
                solution['variables'][var_name] = value if value is not None else 0.0
                solution['variable_types'][var_name] = var_type

            return solution
        except:
            return None

    def print_solution(self):
        solution = self.get_solution()
        if not solution:
            print("âŒ No solution available")
            return

        print(f"\nğŸ“Š {solution['problem_type']} SOLUTION")
        print("=" * 50)
        print(f"Objective Value: {solution['objective_value']:.6f}")

        # Show variable types for mixed problems
        if solution['has_mixed_variables']:
            print("Variable Types:")
            continuous_vars = [name for name, vtype in solution['variable_types'].items()
                               if vtype == 'continuous']
            integer_vars = [name for name, vtype in solution['variable_types'].items()
                            if vtype == 'integer']
            binary_vars = [name for name, vtype in solution['variable_types'].items()
                           if vtype == 'binary']

            if continuous_vars:
                print(f"  Continuous: {', '.join(continuous_vars)}")
            if integer_vars:
                print(f"  Integer: {', '.join(integer_vars)}")
            if binary_vars:
                print(f"  Binary: {', '.join(binary_vars)}")

        print("Variable Values:")
        for name, value in solution['variables'].items():
            var_type = solution['variable_types'][name]
            if var_type in ['integer', 'binary'] and abs(value - round(value)) < 1e-6:
                print(f"  {name} = {int(round(value))} ({var_type})")
            else:
                print(f"  {name} = {value:.6f} ({var_type})")

    def plot_solution_2d(self, x_range=None, y_range=None, title=None, figsize=(10, 7)):
        """Plot 2D solution with ALL ENGLISH LABELS"""
        solution = self.get_solution()
        if not solution or len(solution['variables']) != 2:
            print(
                f"âš ï¸ Cannot plot: Problem has {len(solution['variables']) if solution else 0} variables (need exactly 2 for 2D plot)")
            return

        if x_range is None:
            x_range = (0, 10)
        if y_range is None:
            y_range = (0, 10)
        if title is None:
            title = f"{self.name}"

        # Get solution point and variable types
        vars_list = list(solution['variables'].items())
        x_opt, y_opt = vars_list[0][1], vars_list[1][1]
        x_name, y_name = vars_list[0][0], vars_list[1][0]
        x_type = solution['variable_types'][x_name]
        y_type = solution['variable_types'][y_name]

        # Create plot with ALL ENGLISH LABELS
        fig, ax = plt.subplots(figsize=figsize)

        # Plot optimal point with markers based on variable types
        if x_type in ['integer', 'binary'] or y_type in ['integer', 'binary']:
            ax.plot(x_opt, y_opt, 'rs', markersize=14, zorder=5,
                    label=f'Optimal Solution\n({x_opt:.3f}, {y_opt:.3f})')
        else:
            ax.plot(x_opt, y_opt, 'ro', markersize=14, zorder=5,
                    label=f'Optimal Solution\n({x_opt:.3f}, {y_opt:.3f})')

        # Annotation with ENGLISH TEXT and variable types
        annotation_text = (f'Optimal Point\n'
                           f'{x_name}: {x_opt:.3f} ({x_type})\n'
                           f'{y_name}: {y_opt:.3f} ({y_type})\n'
                           f'Objective Value: {solution["objective_value"]:.3f}')

        ax.annotate(annotation_text,
                    xy=(x_opt, y_opt),
                    xytext=(x_opt + (x_range[1] - x_range[0]) * 0.15,
                            y_opt + (y_range[1] - y_range[0]) * 0.15),
                    arrowprops=dict(arrowstyle='->', color='red', lw=2),
                    bbox=dict(boxstyle="round,pad=0.5", facecolor="yellow", alpha=0.8),
                    fontsize=12, ha='left')

        # Set ALL ENGLISH AXIS LABELS
        ax.set_xlim(x_range)
        ax.set_ylim(y_range)
        ax.set_xlabel(f'{x_name} ({x_type})', fontsize=14, fontweight='bold')
        ax.set_ylabel(f'{y_name} ({y_type})', fontsize=14, fontweight='bold')
        ax.set_title(f'{title} ({solution["problem_type"]} Problem)',
                     fontsize=16, fontweight='bold')

        ax.grid(True, alpha=0.3)
        ax.legend(fontsize=12, loc='best')

        # Add variable information box in ENGLISH
        if solution['has_mixed_variables']:
            info_text = "Mixed Variable Types:\n"
            for name, vtype in solution['variable_types'].items():
                info_text += f"{name}: {vtype}\n"

            ax.text(0.02, 0.98, info_text.strip(), transform=ax.transAxes,
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.7),
                    fontsize=10, verticalalignment='top')

        # ENGLISH TIMESTAMP
        timestamp_text = f"Generated: 2025-06-20 10:58:07 UTC | User: giraffishh"
        fig.text(0.99, 0.01, timestamp_text, ha='right', va='bottom',
                 fontsize=9, alpha=0.6)

        plt.tight_layout()
        plt.show()
        print(f"âœ… Plot created for {solution['problem_type']} problem with ALL ENGLISH LABELS")


# Example 1: LP - x,y (continuous, continuous)
def example_linear_programming():
    """Example 1: Linear Programming - All continuous variables"""
    print("ğŸ¯Example 1: Linear Programming (LP)")
    print("Variables: x,y (continuous, continuous)")
    print("Maximize: 3x + 2y")
    print("Subject to: x + y â‰¤ 4, 2x + y â‰¤ 6, x,y â‰¥ 0")

    solver = OptimizationSolver("Linear_Programming")
    solver.create_model(n_vars=2, var_names=['x', 'y'],
                        var_types=['continuous', 'continuous'], lb=[0, 0])

    # Linear objective
    def objective(model):
        return 3 * model.x[1] + 2 * model.x[2]

    solver.set_objective(objective, 'maximize')
    solver.add_linear_constraints(A=[[1, 1], [2, 1]], b=[4, 6], sense='<=')

    if solver.solve():
        solver.print_solution()
        solver.plot_solution_2d(x_range=(0, 5), y_range=(0, 5), title="Linear Programming")
        return solver.get_solution()
    return None


# Example 2: MILP - x,y (continuous, integer)
def example_mixed_integer_programming():
    """Example 2: Mixed Integer Linear Programming - Mixed variables"""
    print("\nğŸ¯Example 2: Mixed Integer Linear Programming (MILP)")
    print("Variables: x,y (continuous, integer)")
    print("Minimize: 2x + 3y")
    print("Subject to: x + 2y â‰¥ 5, x â‰¥ 0 (continuous), y âˆˆ Z+ (integer)")

    solver = OptimizationSolver("Mixed_Integer_Programming")
    solver.create_model(n_vars=2, var_names=['x', 'y'],
                        var_types=['continuous', 'integer'], lb=[0, 0])

    # Linear objective with mixed variables
    def objective(model):
        return 2 * model.x[1] + 3 * model.x[2]

    solver.set_objective(objective, 'minimize')
    solver.add_linear_constraints(A=[[1, 2]], b=[5], sense='>=')

    if solver.solve():
        solver.print_solution()
        solver.plot_solution_2d(x_range=(0, 6), y_range=(0, 4), title="Mixed Integer Programming")
        return solver.get_solution()
    return None


# Example 3: NLP - x,y (continuous, continuous) with sqrt and cubic
def example_nonlinear_programming():
    """Example 3: Nonlinear Programming - sqrt and cubic terms"""
    print("\nğŸ¯Example 3: Nonlinear Programming (NLP)")
    print("Variables: x,y (continuous, continuous)")
    print("Minimize: sqrt(x) + yÂ³ + 0.1x + 0.1y")
    print("Subject to: x + y â‰¥ 2, x â‰¥ 0.01, y â‰¥ 0.01")

    solver = OptimizationSolver("Nonlinear_Programming")
    solver.create_model(n_vars=2, var_names=['x', 'y'],
                        var_types=['continuous', 'continuous'],
                        lb=[0.01, 0.01], ub=[10, 10])

    # Nonlinear objective with sqrt(x) and yÂ³
    def objective(model):
        return (pyo.sqrt(model.x[1]) + model.x[2] ** 3 +
                0.1 * model.x[1] + 0.1 * model.x[2])

    solver.set_objective(objective, 'minimize')

    # Linear constraint
    def constraint(model):
        return model.x[1] + model.x[2] - 2

    solver.add_constraint(constraint, '>=')

    if solver.solve():
        solver.print_solution()
        solver.plot_solution_2d(x_range=(0, 5), y_range=(0, 3), title="Nonlinear Programming")
        return solver.get_solution()
    return None


# Example 4: QP - x,y (continuous, continuous)
def example_quadratic_programming():
    """Example 4: Quadratic Programming - Quadratic terms"""
    print("\nğŸ¯Example 4: Quadratic Programming (QP)")
    print("Variables: x,y (continuous, continuous)")
    print("Minimize: xÂ² + yÂ² - 4x - 6y")
    print("Subject to: x + y â‰¤ 5, x,y â‰¥ 0")
    solver = OptimizationSolver("Quadratic_Programming")

    # Quadratic objective
    def objective(model):
        return model.x[1] ** 2 + model.x[2] ** 2 - 4 * model.x[1] - 6 * model.x[2]

    # Support chain calls
    solver.create_model(n_vars=2, var_names=['x', 'y'],
                        var_types=['continuous', 'continuous'], lb=[0, 0]) \
        .set_objective(objective, 'minimize') \
        .add_linear_constraints(A=[[1, 1]], b=[5], sense='<=')

    if solver.solve():
        solver.print_solution()
        solver.plot_solution_2d(x_range=(0, 6), y_range=(0, 6), title="Quadratic Programming")
        return solver.get_solution()
    return None


def main():
    """Main function with updated examples"""

    # Run 4 updated examples
    results = []

    try:
        results.append(example_linear_programming())  # LP - x,y (continuous, continuous)
        results.append(example_mixed_integer_programming())  # MILP - x,y (continuous, integer)
        results.append(example_nonlinear_programming())  # NLP - x,y (continuous, continuous) with sqrt and cubic
        results.append(example_quadratic_programming())  # QP - x,y (continuous, continuous)

    except Exception as e:
        print(f"âŒ Error: {e}")

    # Summary with ALL ENGLISH labels
    print(f"\nğŸ“Š SUMMARY")
    print("=" * 70)

    examples = [
        ("Linear Programming", "LP", "x,y (continuous, continuous)"),
        ("Mixed Integer Linear Programming", "MILP", "x,y (continuous, integer)"),
        ("Nonlinear Programming", "NLP", "x,y (continuous, continuous) - sqrt & cubic"),
        ("Quadratic Programming", "QP", "x,y (continuous, continuous)")
    ]

    successful = sum(1 for r in results if r is not None)

    for i, (name, expected_type, description) in enumerate(examples):
        if i < len(results) and results[i] is not None:
            actual_type = results[i]['problem_type']
            has_mixed = results[i].get('has_mixed_variables', False)
            mixed_info = " (Mixed Variables)" if has_mixed else ""
            print(f"âœ… {name}: {actual_type}{mixed_info} - {description}")
        else:
            print(f"âŒ {name}: Failed")

    print(f"\nSolved: {successful}/4 problems")

if __name__ == "__main__":
    main()
```

**è¯´æ˜:**

| æ–¹æ³•                                                 | åŠŸèƒ½         | ç¤ºä¾‹                                                        |
| ---------------------------------------------------- | ------------ | ----------------------------------------------------------- |
| `create_model(n_vars, var_names, var_types, lb, ub)` | åˆ›å»ºæ¨¡å‹     | `solver.create_model(2, ['x','y'], 'continuous', lb=[0,0])` |
| `set_objective(objective_func, sense)`               | è®¾ç½®ç›®æ ‡å‡½æ•° | `solver.set_objective(obj_func, 'maximize')`                |
| `add_linear_constraints(A, b, sense)`                | æ·»åŠ çº¿æ€§çº¦æŸ | `solver.add_linear_constraints([[1,1]], [5], '<=')`         |
| `add_constraint(constraint_func, sense)`             | æ·»åŠ å•ä¸ªçº¦æŸ | `solver.add_constraint(constraint, '>=')`                   |
| `solve(solver, options, verbose)`                    | æ±‚è§£é—®é¢˜     | `solver.solve()`                                            |
| `print_solution()`                                   | æ‰“å°è§£       | `solver.print_solution()`                                   |
| `plot_solution_2d()`                                 | 2Då›¾è¡¨       | `solver.plot_solution_2d()`                                 |

æ”¯æŒæ–¹æ³•é“¾å¼è°ƒç”¨

```python
solver.create_model(2, ['x','y'], lb=[0,0]) \
      .set_objective(obj_func, 'maximize') \
      .add_linear_constraints(A, b, '<=') \
      .solve()
```

æ³¨æ„ï¼šåœ¨æ„é€ ç¬¦å·è¡¨è¾¾å¼åº”ä½¿ç”¨Pyomoä¸­çš„æ–¹æ³•è€Œä¸æ˜¯Pythonçš„`math`åº“

```python
# ç¤ºä¾‹
import pyomo.environ as pyo

pyo.sqrt(model.x[1])
```

- `exp(x)`ï¼šæŒ‡æ•°å‡½æ•° $e^x$
- `log(x)`ï¼šè‡ªç„¶å¯¹æ•° $\ln(x)$ï¼ˆè¦æ±‚ $x > 0$ï¼‰
- `log10(x)`ï¼šä»¥ 10 ä¸ºåº•çš„å¯¹æ•° $\log_{10}(x)$
- `sqrt(x)`ï¼šå¹³æ–¹æ ¹ $\sqrt{x}$
- `x ** n`ï¼šå¹‚å‡½æ•°ï¼ˆæ”¯æŒå˜é‡æˆ–è¡¨è¾¾å¼çš„å¹‚ï¼‰
- `sin(x)`ï¼šæ­£å¼¦å‡½æ•°
- `cos(x)`ï¼šä½™å¼¦å‡½æ•°
- `tan(x)`ï¼šæ­£åˆ‡å‡½æ•°
- `asin(x)`ï¼šåæ­£å¼¦ï¼ˆå€¼åŸŸä¸º [-Ï€/2, Ï€/2]ï¼‰
- `acos(x)`ï¼šåä½™å¼¦ï¼ˆå€¼åŸŸä¸º [0, Ï€]ï¼‰
- `atan(x)`ï¼šåæ­£åˆ‡ï¼ˆå€¼åŸŸä¸º [-Ï€/2, Ï€/2]ï¼‰
- `sinh(x)`ï¼šåŒæ›²æ­£å¼¦
- `cosh(x)`ï¼šåŒæ›²ä½™å¼¦
- `tanh(x)`ï¼šåŒæ›²æ­£åˆ‡
- `abs(x)`ï¼šç»å¯¹å€¼ï¼ˆè‡ªåŠ¨å¼•å…¥çº¦æŸï¼‰
- `ceil(x)`ï¼šå‘ä¸Šå–æ•´ï¼ˆæ•´æ•°è§„åˆ’ä¸­æ…ç”¨ï¼‰
- `floor(x)`ï¼šå‘ä¸‹å–æ•´ï¼ˆåŒä¸Šï¼‰
- `max_(x, y)`ï¼šæœ€å¤§å€¼ï¼ˆæ³¨æ„æœ«å°¾æ˜¯ä¸‹åˆ’çº¿ï¼Œé¿å…ä¸ Python ä¿ç•™å­—å†²çªï¼‰
- `min_(x, y)`ï¼šæœ€å°å€¼

> æ³¨æ„æŸäº›å‡½æ•°ï¼ˆå¦‚ logã€sqrtï¼‰åœ¨è¾¹ç•Œç‚¹ï¼ˆå¦‚ 0ï¼‰æ±‚å¯¼ä¼šå‡ºé”™ï¼Œåº”è®¾ç½®åˆç†çš„å˜é‡ä¸‹é™

## å±‚æåˆ†ææ³•ï¼ˆAHPï¼‰

â€œå±‚æ¬¡åˆ†ææ³•â€ï¼ˆAnalytic Hierarchy Processï¼Œç®€ç§° AHPï¼‰æ˜¯ä¸€ç§**å¤šå‡†åˆ™å†³ç­–åˆ†ææ–¹æ³•**ï¼Œç”±ç¾å›½è¿ç­¹å­¦å®¶æ‰˜é©¬æ–¯Â·è¨è’‚ï¼ˆThomas L. Saatyï¼‰åœ¨20ä¸–çºª70å¹´ä»£æå‡ºçš„ã€‚å®ƒç”¨äºå°†å¤æ‚çš„å†³ç­–é—®é¢˜åˆ†è§£æˆå¤šä¸ªå±‚æ¬¡ç»“æ„ï¼Œå¹¶é€šè¿‡æˆå¯¹æ¯”è¾ƒå’Œä¸€è‡´æ€§æ£€éªŒæ¥ç¡®å®šå„å› ç´ çš„ç›¸å¯¹é‡è¦æ€§

å±‚æ¬¡åˆ†ææ³•çš„ä¸‰å¤§å…¸å‹åº”ç”¨

1. ç”¨äºæœ€ä½³æ–¹æ¡ˆçš„é€‰å–ï¼ˆé€‰æ‹©åœ°å€ï¼‰
2. ç”¨äºè¯„ä»·ç±»é—®é¢˜ï¼ˆè¯„ä»·æ°´è´¨çŠ¶å†µã€è¯„ä»·ç¯å¢ƒï¼‰
3. ç”¨äºæŒ‡æ ‡ä½“ç³»çš„ä¼˜é€‰ï¼ˆå…¼é¡¾ç§‘å­¦å’Œæ•ˆç‡ï¼‰

### æ ¸å¿ƒæ­¥éª¤

1. **å»ºç«‹å±‚æ¬¡ç»“æ„æ¨¡å‹** 
   å°†é—®é¢˜æŠ½è±¡æˆç›®æ ‡ã€å‡†åˆ™å’Œæ–¹æ¡ˆä¸‰ä¸ªå±‚æ¬¡ï¼Œå½¢æˆæ ‘çŠ¶ç»“æ„ã€‚

2. **æ„é€ åˆ¤æ–­çŸ©é˜µ**
   é‡‡ç”¨æˆå¯¹æ¯”è¾ƒçš„æ–¹æ³•ï¼Œä¸“å®¶å¯¹æ¯ä¸€å±‚å› ç´ è¿›è¡Œä¸¤ä¸¤æ¯”è¾ƒï¼Œä½¿ç”¨ 1~9 æ ‡åº¦æ³•å¡«å†™åˆ¤æ–­çŸ©é˜µã€‚ä¾‹å¦‚ï¼Œâ€œå› ç´  A æ¯”å› ç´  B é‡è¦â€å¯ç”¨æ•°å€¼è¡¨ç¤ºã€‚

3. **è®¡ç®—æƒé‡å‘é‡**
   æ±‚è§£åˆ¤æ–­çŸ©é˜µçš„ç‰¹å¾å‘é‡ï¼Œå¾—åˆ°æ¯ä¸ªå› ç´ çš„ç›¸å¯¹æƒé‡ï¼ˆå³é‡è¦æ€§ï¼‰ã€‚

4. **ä¸€è‡´æ€§æ£€éªŒ**
   åˆ¤æ–­ä¸“å®¶æ‰“åˆ†æ˜¯å¦é€»è¾‘ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´ï¼ˆCI å€¼è¶…è¿‡é˜ˆå€¼ï¼‰ï¼Œéœ€è¦é‡æ–°æ‰“åˆ†ã€‚

5. **ç»¼åˆæƒé‡è®¡ç®—**
   é€å±‚è®¡ç®—å‡ºæœ€ç»ˆæ¯ä¸ªæ–¹æ¡ˆçš„ç»¼åˆå¾—åˆ†ï¼Œé€‰æ‹©å¾—åˆ†æœ€é«˜çš„æ–¹æ¡ˆã€‚

#### 1. å»ºç«‹å±‚æ¬¡ç»“æ„æ¨¡å‹

AHP é€šè¿‡å°†å¤æ‚é—®é¢˜ç»“æ„åŒ–ï¼Œåˆ†æˆä¸‰ä¸ªä¸»è¦å±‚æ¬¡ï¼š

1. **ç›®æ ‡å±‚ï¼ˆç›®æ ‡ï¼‰**ï¼šå†³ç­–çš„æœ€ç»ˆç›®æ ‡ï¼Œæ¯”å¦‚â€œé€‰å‡ºæœ€ä¼˜æ–¹æ¡ˆâ€
2. **å‡†åˆ™å±‚ï¼ˆæˆ–å«æ ‡å‡†å±‚ï¼‰**ï¼šå½±å“ç›®æ ‡å®ç°çš„å‡†åˆ™æˆ–æŒ‡æ ‡
3. **æ–¹æ¡ˆå±‚**ï¼šå¤‡é€‰çš„å†³ç­–æ–¹æ¡ˆ

**ç¤ºä¾‹:**

![](https://cdn.giraffish.me/blog/25-06-24-1750745008263.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750745017254.webp)

#### 2. æ„é€ åˆ¤æ–­ï¼ˆæˆå¯¹æ¯”è¾ƒï¼‰çŸ©é˜µ

åœ¨ç¡®å®šå„å±‚æ¬¡å„å› ç´ ä¹‹é—´çš„æƒé‡æ—¶ï¼Œå¦‚æœåªæ˜¯å®šæ€§çš„ç»“æœï¼Œå¸¸å¸¸ä¸å®¹æ˜“è¢«ä»–äººæ¥å—ã€‚å› æ­¤ï¼ŒSaaty ç­‰äººæå‡ºâ€œä¸€è‡´çŸ©é˜µæ³•â€ï¼Œå…¶ä¸»è¦æ€æƒ³åŒ…æ‹¬ï¼š

1. ä¸æŠŠæ‰€æœ‰å› ç´ æ”¾åœ¨ä¸€èµ·æ¯”è¾ƒï¼Œè€Œæ˜¯**ä¸¤ä¸¤ç›¸äº’æ¯”è¾ƒ**ï¼›
2. é‡‡ç”¨**ç›¸å¯¹å°ºåº¦**ï¼Œå°½å¯èƒ½å‡å°‘æ€§è´¨ä¸åŒçš„å› ç´ ç›´æ¥æ¯”è¾ƒçš„å›°éš¾ï¼Œä»¥æé«˜åˆ¤æ–­çš„å‡†ç¡®åº¦ã€‚

åˆ¤æ–­çŸ©é˜µç”¨äºè¡¨ç¤ºæœ¬å±‚æ‰€æœ‰å› ç´ **é’ˆå¯¹ä¸Šä¸€å±‚æŸä¸€ä¸ªå› ç´ **çš„ç›¸å¯¹é‡è¦æ€§ã€‚åˆ¤æ–­çŸ©é˜µä¸­çš„å…ƒç´  $a_{ij}$ ç”± Saaty æå‡ºçš„ **1â€”9 æ ‡åº¦æ³•**ç»™å‡ºï¼Œç”¨æ¥é‡åŒ–â€œå› ç´  $i$ ç›¸å¯¹äºå› ç´  $j$ çš„é‡è¦æ€§â€

å¿ƒç†å­¦ç ”ç©¶è¡¨æ˜ï¼Œ**æˆå¯¹æ¯”è¾ƒçš„å› ç´ ä¸å®œè¶…è¿‡ 9 ä¸ª**ï¼Œå› æ­¤æ¯ä¸€å±‚çš„å› ç´ æ•°é‡é€šå¸¸æ§åˆ¶åœ¨ 9 ä¸ªä»¥å†…

**åˆ¤æ–­çŸ©é˜µå…ƒç´  $a_{ij}$ çš„æ ‡åº¦æ–¹æ³•**

| æ ‡åº¦       | å«ä¹‰                                                         |
| ---------- | ------------------------------------------------------------ |
| 1          | è¡¨ç¤ºä¸¤ä¸ªå› ç´ ç›¸æ¯”ï¼Œå…·æœ‰åŒæ ·é‡è¦æ€§                             |
| 3          | è¡¨ç¤ºä¸¤ä¸ªå› ç´ ç›¸æ¯”ï¼Œä¸€ä¸ªå› ç´ æ¯”å¦ä¸€ä¸ªå› ç´ ç¨å¾®é‡è¦               |
| 5          | è¡¨ç¤ºä¸¤ä¸ªå› ç´ ç›¸æ¯”ï¼Œä¸€ä¸ªå› ç´ æ¯”å¦ä¸€ä¸ªå› ç´ æ˜æ˜¾é‡è¦               |
| 7          | è¡¨ç¤ºä¸¤ä¸ªå› ç´ ç›¸æ¯”ï¼Œä¸€ä¸ªå› ç´ æ¯”å¦ä¸€ä¸ªå› ç´ å¼ºçƒˆé‡è¦               |
| 9          | è¡¨ç¤ºä¸¤ä¸ªå› ç´ ç›¸æ¯”ï¼Œä¸€ä¸ªå› ç´ æ¯”å¦ä¸€ä¸ªå› ç´ æç«¯é‡è¦               |
| 2, 4, 6, 8 | ä¸Šè¿°ä¸¤ç›¸é‚»åˆ¤æ–­çš„ä¸­å€¼                                         |
| å€’æ•°       | å› ç´  $i$ ä¸ $j$ æ¯”è¾ƒçš„åˆ¤æ–­ $a_{ij}$ï¼Œåˆ™å› ç´  $j$ ä¸ $i$ æ¯”è¾ƒçš„åˆ¤æ–­ $a_{ji} = 1/a_{ij}$ |

![](https://cdn.giraffish.me/blog/25-06-24-1750745981093.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750745989626.webp)

#### 3. è®¡ç®—æƒé‡å‘é‡

![](https://cdn.giraffish.me/blog/25-06-24-1750745999875.webp)

#### 4. ä¸€è‡´æ€§æ£€éªŒ

![](https://cdn.giraffish.me/blog/25-06-24-1750750945258.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750750974635.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750750960270.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750751627685.webp)

#### 5. ç»¼åˆæƒé‡è®¡ç®—

ä¸Šè¿°æ­¥éª¤2-4å®Œæˆäº†**å‡†åˆ™å±‚åˆ°ç›®æ ‡å±‚**çš„æƒé‡å‘é‡ï¼ˆå±‚æ¬¡å•æ’åºï¼‰ï¼Œç°åœ¨éœ€è¦é‡å¤2-4çš„æ­¥éª¤ï¼Œå®Œæˆ**æ–¹æ¡ˆå±‚å¯¹æ¯ä¸€ä¸ªå‡†åˆ™å±‚**çš„æƒé‡å‘é‡ï¼Œå³**æ–¹æ¡ˆ**åœ¨æ¯ä¸€ä¸ª**è¯„åˆ¤å‡†åˆ™**ä¸Šçš„â€œå¾—åˆ†â€ï¼Œ$\sum (\text{å¾—åˆ†} \times \text{æƒé‡}) = \text{æ€»å¾—åˆ†}$ï¼Œå³å±‚æ¬¡æ€»æ’åº

![](https://cdn.giraffish.me/blog/25-06-24-1750751345690.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750751709182.webp)

**å±‚æ¬¡æ€»æ’åºçš„ä¸€è‡´æ€§æ£€éªŒ**

![](https://cdn.giraffish.me/blog/25-06-24-1750751764758.webp)

**ç¤ºä¾‹**

![](https://cdn.giraffish.me/blog/25-06-24-1750751801319.webp)

![](https://cdn.giraffish.me/blog/25-06-24-1750751821557.webp)

### ç¤ºä¾‹ä»£ç 

```python
import numpy as np
from scipy.linalg import eig


class AHP:
    """
    A class to implement the Analytic Hierarchy Process.
    """

    def __init__(self, criteria_matrix, alternatives_matrices):
        """
        Initialize the AHP model.
        :param criteria_matrix: The pairwise comparison matrix for the criteria.
        :param alternatives_matrices: A list of pairwise comparison matrices for the alternatives,
                                      one for each criterion.
        """
        self.criteria_matrix = np.array(criteria_matrix, dtype=float)
        self.alternatives_matrices = [np.array(m, dtype=float) for m in alternatives_matrices]

        self.num_criteria = self.criteria_matrix.shape[0]
        self.num_alternatives = self.alternatives_matrices[0].shape[0]

        # Predefined Random Index (RI) for matrices of size 1 to 10
        # Saaty's 1980 RI values
        self.RI = {
            1: 0, 2: 0, 3: 0.58, 4: 0.90, 5: 1.12,
            6: 1.24, 7: 1.32, 8: 1.41, 9: 1.45, 10: 1.49
        }

    def _calculate_weights(self, matrix):
        """
        Calculate the priority vector (weights) from a pairwise comparison matrix.
        This uses the principal eigenvalue method.
        """
        # Calculate eigenvalues and eigenvectors
        eigenvalues, eigenvectors = eig(matrix)

        # Find the index of the largest real eigenvalue
        max_eigenvalue_index = np.argmax(np.real(eigenvalues))

        # Get the corresponding eigenvector
        principal_eigenvector = np.real(eigenvectors[:, max_eigenvalue_index])

        # Normalize the eigenvector to get weights (ensure positive values)
        if np.sum(principal_eigenvector) < 0:
            principal_eigenvector = -principal_eigenvector

        weights = principal_eigenvector / np.sum(principal_eigenvector)

        return weights

    def _check_consistency(self, matrix):
        """
        Check the consistency of a pairwise comparison matrix.
        Returns the Consistency Ratio (CR). A CR of 0.10 or less is considered acceptable.
        """
        n = matrix.shape[0]
        if n <= 2:
            return 0.0  # Matrices of size 1 or 2 are always consistent

        weights = self._calculate_weights(matrix)

        # Calculate lambda_max
        weighted_sum_vector = np.dot(matrix, weights)
        lambda_max = np.mean(weighted_sum_vector / weights)

        # Calculate Consistency Index (CI)
        CI = (lambda_max - n) / (n - 1)

        # Get Random Index (RI)
        RI = self.RI.get(n)
        if RI is None or RI == 0:
            return float('inf')  # Should not happen for n > 2 with the given RI table

        # Calculate Consistency Ratio (CR)
        CR = CI / RI
        return CR

    def calculate_final_scores(self):
        """
        Calculate the final scores for each alternative.
        """
        # 1. Calculate criteria weights and check consistency
        criteria_weights = self._calculate_weights(self.criteria_matrix)
        criteria_cr = self._check_consistency(self.criteria_matrix)

        print("--- Criteria Analysis ---")
        print(f"Criteria Weights: {np.round(criteria_weights, 4)}")
        print(f"Criteria Consistency Ratio (CR): {criteria_cr:.4f}")
        if criteria_cr > 0.1:
            print("Warning: The criteria comparison matrix is inconsistent (CR > 0.1).")
        print("-" * 25)

        # 2. Calculate alternative weights for each criterion
        alternative_weights_matrix = []
        for i, alt_matrix in enumerate(self.alternatives_matrices):
            alt_weights = self._calculate_weights(alt_matrix)
            alt_cr = self._check_consistency(alt_matrix)
            alternative_weights_matrix.append(alt_weights)

            print(f"\n--- Analysis for Criterion {i + 1} ---")
            print(f"Alternative Weights: {np.round(alt_weights, 4)}")
            print(f"Consistency Ratio (CR): {alt_cr:.4f}")
            if alt_cr > 0.1:
                print(f"Warning: The alternative comparison matrix for criterion {i + 1} is inconsistent (CR > 0.1).")
            print("-" * 25)

        # 3. Synthesize the results to get final scores
        alternative_weights_matrix = np.array(alternative_weights_matrix).T
        final_scores = np.dot(alternative_weights_matrix, criteria_weights)

        return final_scores

if __name__ == '__main__':
    # --- Step 1: Define your problem ---
    # Goal: Choose the best car

    criteria_labels = ["Price", "Safety", "Performance"]
    alternatives_labels = ["Car A", "Car B", "Car C"]

    # --- Step 2: Create pairwise comparison matrices ---
    # These matrices represent subjective judgments.
    # The scale typically ranges from 1 (equal importance) to 9 (extreme importance).
    # If criterion A is '3' times more important than B, then B is '1/3' as important as A.

    # 2.1. Pairwise comparison matrix for the criteria
    #       Price   Safety  Performance
    # Price   1        3         5
    # Safety 1/3       1         2
    # Perf.  1/5      1/2        1
    criteria_matrix = [
        [1, 3, 5],
        [1 / 3, 1, 2],
        [1 / 5, 1 / 2, 1]
    ]

    # 2.2. Pairwise comparison matrices for alternatives for each criterion
    # For "Price" (lower is better, so a cheaper car gets a higher score)
    #       Car A   Car B   Car C
    # Car A   1        5       2
    # Car B  1/5       1      1/3
    # Car C  1/2       3       1
    alternatives_price = [
        [1, 5, 2],
        [1 / 5, 1, 1 / 3],
        [1 / 2, 3, 1]
    ]

    # For "Safety"
    #       Car A   Car B   Car C
    # Car A   1      1/5     1/2
    # Car B   5       1       3
    # Car C   2      1/3      1
    alternatives_safety = [
        [1, 1 / 5, 1 / 2],
        [5, 1, 3],
        [2, 1 / 3, 1]
    ]

    # For "Performance"
    #       Car A   Car B   Car C
    # Car A   1      1/3     1/7
    # Car B   3       1      1/3
    # Car C   7       3       1
    alternatives_performance = [
        [1, 1 / 3, 1 / 7],
        [3, 1, 1 / 3],
        [7, 3, 1]
    ]

    alternatives_matrices = [alternatives_price, alternatives_safety, alternatives_performance]

    # --- Step 3: Run the AHP calculation ---
    ahp_model = AHP(criteria_matrix, alternatives_matrices)
    final_scores = ahp_model.calculate_final_scores()

    # --- Step 4: Display the final results ---
    print("\n\n--- Final Results ---")
    for i, score in enumerate(final_scores):
        print(f"Final Score for {alternatives_labels[i]}: {score:.4f}")

    best_alternative_index = np.argmax(final_scores)
    print(f"\nBased on the AHP model, the best choice is: {alternatives_labels[best_alternative_index]}")
```
## TOPSIS + ç†µæƒæ³•

**TOPSIS**ï¼ˆTechnique for Order Preference by Similarity to Ideal Solutionï¼Œä¼˜åŠ£è§£è·ç¦»æ³•ï¼‰æ˜¯ä¸€ç§å¸¸ç”¨çš„ç»¼åˆè¯„ä»·æ–¹æ³•ï¼Œèƒ½å……åˆ†åˆ©ç”¨åŸå§‹æ•°æ®çš„ä¿¡æ¯ï¼Œå…¶ç»“æœèƒ½ç²¾ç¡®åœ°åæ˜ å„è¯„ä»·æ–¹æ¡ˆä¹‹é—´çš„å·®è·

TOPSISæ³•å¼•å…¥äº†ä¸¤ä¸ªåŸºæœ¬æ¦‚å¿µï¼š
**ç†æƒ³è§£**ï¼šè®¾æƒ³çš„æœ€ä¼˜çš„è§£ï¼ˆæ–¹æ¡ˆï¼‰ï¼Œå®ƒçš„å„ä¸ªå±æ€§å€¼éƒ½è¾¾åˆ°å„å¤‡é€‰æ–¹æ¡ˆä¸­çš„æœ€å¥½çš„å€¼
**è´Ÿç†æƒ³è§£**ï¼šè®¾æƒ³çš„æœ€åŠ£çš„è§£ï¼ˆæ–¹æ¡ˆï¼‰ï¼Œå®ƒçš„å„ä¸ªå±æ€§å€¼éƒ½è¾¾åˆ°å„å¤‡é€‰æ–¹æ¡ˆä¸­çš„æœ€åçš„å€¼

æ–¹æ¡ˆæ’åºçš„è§„åˆ™æ˜¯æŠŠå„å¤‡é€‰æ–¹æ¡ˆä¸ç†æƒ³è§£å’Œè´Ÿç†æƒ³è§£åšæ¯”è¾ƒï¼Œè‹¥å…¶ä¸­æœ‰ä¸€ä¸ªæ–¹æ¡ˆ**æœ€æ¥è¿‘ç†æƒ³è§£**ï¼Œè€ŒåŒæ—¶åˆ**è¿œç¦»è´Ÿç†æƒ³è§£**ï¼Œåˆ™è¯¥æ–¹æ¡ˆæ˜¯å¤‡é€‰æ–¹æ¡ˆä¸­æœ€å¥½çš„æ–¹æ¡ˆã€‚TOPSISé€šè¿‡æœ€æ¥è¿‘ç†æƒ³è§£ä¸”æœ€è¿œç¦»è´Ÿç†æƒ³è§£æ¥**ç¡®å®šæœ€ä¼˜é€‰æ‹©**

**ç†µæƒæ³•**æ˜¯ä¸€ç§**å®¢è§‚èµ‹æƒæ–¹æ³•**ï¼ŒåŸºäºä¿¡æ¯ç†µç†è®ºç¡®å®šå„è¯„ä»·æŒ‡æ ‡çš„æƒé‡ï¼Œå¯ç”¨äºå¤šç§å¤šæŒ‡æ ‡ç»¼åˆè¯„ä»·æ–¹æ³•ä¸­çš„æƒé‡è®¡ç®—ï¼Œå…¶æ ¸å¿ƒæ€æƒ³ä¸ºï¼š

- æŒ‡æ ‡å€¼å·®å¼‚è¶Šå¤§ï¼ŒåŒ…å«çš„ä¿¡æ¯è¶Šå¤šï¼Œæƒé‡åº”è¶Šå¤§
- æŒ‡æ ‡å€¼è¶Šæ¥è¿‘ï¼Œè¯´æ˜ä¿¡æ¯è¶Šå°‘ï¼Œæƒé‡åº”è¶Šå°

### æ ¸å¿ƒæ­¥éª¤

#### 1. æ„å»º**å†³ç­–çŸ©é˜µ**

æ„å»ºå†³ç­–çŸ©é˜µ $X = [x_{ij}]$ï¼Œå…¶ä¸­ $x_{ij}$ è¡¨ç¤ºç¬¬ $i$ ä¸ªæ–¹æ¡ˆåœ¨ç¬¬ $j$ ä¸ªæŒ‡æ ‡ä¸Šçš„æ•°å€¼ï¼Œ$i=1,2,\dots,m$ï¼Œ$j=1,2,\dots,n$

#### 2. **æ ‡å‡†åŒ–**å†³ç­–çŸ©é˜µ

| æŒ‡æ ‡ç±»å‹             | æŒ‡æ ‡ç‰¹ç‚¹               | ä¾‹å­                          |
|----------------------|------------------------|-------------------------------|
| æå¤§å‹ï¼ˆæ•ˆç›Šå‹ï¼‰æŒ‡æ ‡ | è¶Šå¤§ï¼ˆå¤šï¼‰è¶Šå¥½         | é¢œå€¼ã€æˆç»©ã€GDPå¢é€Ÿ           |
| æå°å‹ï¼ˆæˆæœ¬å‹ï¼‰æŒ‡æ ‡ | è¶Šå°ï¼ˆå°‘ï¼‰è¶Šå¥½         | è„¾æ°”ã€è´¹ç”¨ã€ç¯å“ç‡ã€æ±¡æŸ“ç¨‹åº¦  |
| ä¸­é—´å‹æŒ‡æ ‡           | è¶Šæ¥è¿‘æŸä¸ªå€¼è¶Šå¥½       | èº«é«˜ã€æ°´è´¨é‡è¯„ä¼°æ—¶çš„PHå€¼      |
| åŒºé—´å‹æŒ‡æ ‡           | è½åœ¨æŸä¸ªåŒºé—´æœ€å¥½       | ä½“é‡ã€ä½“æ¸©                    |

- å°†åŸå§‹çŸ©é˜µ**æ­£å‘åŒ–** 
  å°†åŸå§‹çŸ©é˜µæ­£å‘åŒ–ï¼Œå°±æ˜¯è¦å°†æ‰€æœ‰çš„æŒ‡æ ‡ç±»å‹ç»Ÿä¸€è½¬åŒ–ä¸º**æå¤§å‹æŒ‡æ ‡**

| **æŒ‡æ ‡åç§°**         | **å…¬å¼**                                                     | **è¯´æ˜**                                                   |
| -------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| æå¤§å‹ï¼ˆæ•ˆç›Šå‹ï¼‰æŒ‡æ ‡ | /                                                            | /                                                          |
| æå°å‹ï¼ˆæˆæœ¬å‹ï¼‰æŒ‡æ ‡ | $\hat{x} = \max - x$                                         | $\hat{x}$ä¸ºè½¬åŒ–åæŒ‡æ ‡ï¼Œ$\max$ä¸ºæŒ‡æ ‡æœ€å¤§å€¼ï¼Œ$x$ä¸ºåŸå§‹æŒ‡æ ‡å€¼ |
| ä¸­é—´å‹æŒ‡æ ‡           | $\hat{x}_i = 1 - \frac{|x_i - x_{\text{best}}|}{M}$ï¼Œ$M = \max \{|x_i - x_{\text{best}}|\}$ | $\{x_i\}$ æ˜¯ä¸€ç»„ä¸­é—´å‹åºåˆ—ï¼Œ$x_{\text{best}}$ æ˜¯æœ€ä¼˜å€¼     |
| åŒºé—´å‹æŒ‡æ ‡           | $\hat{x}_i = \begin{cases} 1 - \frac{a - x_i}{M}, & x_i < a \\ 1, & a \le x_i \le b \\ 1 - \frac{x_i - b}{M}, & x_i > b \end{cases}$ $M = \max\{a - \min\{x_i\}, \max\{x_i\} - b\}$ | $\{x_i\}$ æ˜¯ä¸€ç»„åŒºé—´å‹åºåˆ—ï¼Œæœ€ä¼˜åŒºé—´ä¸º $[a, b]$            |

- æ­£å‘çŸ©é˜µ**æ ‡å‡†åŒ–** 
  æ ‡å‡†åŒ–çš„æ–¹æ³•æœ‰å¾ˆå¤šç§ï¼Œå…¶ä¸»è¦ç›®çš„å°±æ˜¯**å»é™¤é‡çº²çš„å½±å“**ï¼Œä¿è¯ä¸åŒè¯„ä»·æŒ‡æ ‡åœ¨åŒä¸€æ•°é‡çº§ï¼Œä¸”æ•°æ®å¤§å°æ’åºä¸å˜

å‡è®¾æœ‰ $n$ ä¸ªè¦è¯„ä»·çš„å¯¹è±¡ï¼Œ$m$ ä¸ªè¯„ä»·æŒ‡æ ‡ï¼ˆå·²æ­£å‘åŒ–ï¼‰æ„æˆçš„æ­£å‘åŒ–çŸ©é˜µå¦‚ä¸‹ï¼š

$$
X = 
\begin{bmatrix}
x_{11} & \cdots & x_{1m} \\
\vdots & \ddots & \vdots \\
x_{n1} & \cdots & x_{nm}
\end{bmatrix}
$$

é‚£ä¹ˆï¼Œå¯¹å…¶æ ‡å‡†åŒ–çš„çŸ©é˜µè®°ä¸º $Z$ï¼Œ$Z$ ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼š

$$
Z_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^n x_{ij}^2}}
$$

å³ï¼šæ¯ä¸€ä¸ªå…ƒç´ é™¤ä»¥å…¶æ‰€åœ¨åˆ—çš„å…ƒç´ çš„å¹³æ–¹å’Œçš„å¹³æ–¹æ ¹

#### 3. **ç†µæƒæ³•**åŠ æƒæ ‡å‡†åŒ–çŸ©é˜µ

1. è®¡ç®—æ¦‚ç‡çŸ©é˜µ

$$
p_{ij} = \frac{x_{ij}}{\sum_{i=1}^m x_{ij}}
$$

2. è®¡ç®—ä¿¡æ¯ç†µ

$$
e_j = -\frac{1}{\ln n} \sum_{i=1}^n p_{ij} \ln p_{ij}
$$

> æ³¨æ„ï¼šå½“ $p_{ij} = 0$ æ—¶ï¼Œå®šä¹‰ $p_{ij} \ln p_{ij} = 0$

3. è®¡ç®—ä¿¡æ¯æ•ˆç”¨å€¼

$$
d_j = 1 - e_j
$$

4. è®¡ç®—æŒ‡æ ‡æƒé‡ï¼š

$$
w_j = \frac{d_j}{\sum_{j=1}^m d_j}
$$

5. åˆ©ç”¨æƒé‡åŠ æƒ

å¯¹äºæ ‡å‡†åŒ–çŸ©é˜µ $Z = [z_{ij}]$ï¼Œæ¯åˆ—æ˜¯å½’ä¸€åŒ–çš„å€¼ï¼Œæ¯åˆ—çš„æƒé‡ä¸º $w_j$ï¼Œåˆ™åŠ æƒåçš„çŸ©é˜µ $V = [v_{ij}]$ ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ä¸ºï¼š

$$
v_{ij} = w_j \cdot z_{ij}
$$

#### 4. ç¡®å®šæ­£ç†æƒ³è§£ä¸è´Ÿç†æƒ³è§£

- æ­£ç†æƒ³è§£ï¼ˆæœ€ä¼˜ï¼‰ï¼š$Z^+ = \{v_1^+, v_2^+, \dots, v_n^+\}$
- è´Ÿç†æƒ³è§£ï¼ˆæœ€åŠ£ï¼‰ï¼š$Z^- = \{v_1^-, v_2^-, \dots, v_n^-\}$

å¯¹äºæ¯ä¸ªæŒ‡æ ‡ $j$ï¼š

$$
v_j^+ = \max_i v_{ij}, \quad v_j^- = \min_i v_{ij}
$$

#### 5. è®¡ç®—å„æ–¹æ¡ˆåˆ°ç†æƒ³è§£çš„è·ç¦»

- åˆ°æ­£ç†æƒ³è§£çš„è·ç¦»ï¼š
$$
D_i^+ = \sqrt{\sum_{j=1}^m (v_{ij} - Z_j^+)^2}
$$
- åˆ°è´Ÿç†æƒ³è§£çš„è·ç¦»ï¼š
$$
D_i^- = \sqrt{\sum_{j=1}^m (v_{ij} - Z_j^-)^2}
$$

#### 6. è®¡ç®—è´´è¿‘åº¦ï¼ˆæœ€ç»ˆå¾—åˆ†ï¼‰

$$
S_i = \frac{D_i^+}{D_i^+ + D_i^-}
$$

å…¶ä¸­ $0 \le S_i \le 1$ï¼Œ$S_i$ è¶Šå¤§è¡¨ç¤ºæ–¹æ¡ˆè¶Šä¼˜

å¦å¤–æˆ‘ä»¬å¯ä»¥å°†å¾—åˆ†å½’ä¸€åŒ–å¹¶æ¢æˆç™¾åˆ†åˆ¶

$$
\tilde{S_i} = \frac{S_i}{\sum_{i=1}^{n} S_i} \times 100
$$

#### ç¤ºä¾‹

æ˜æ˜ŸKunåœ¨é€‰npyï¼Œæ„å»ºå†³ç­–çŸ©é˜µ

| å€™é€‰äºº | é¢œå€¼ | è„¾æ°”ï¼ˆäº‰åµæ¬¡æ•°ï¼‰ | èº«é«˜ | ä½“é‡ |
| ------ | ---- | ---------------- | ---- | ---- |
| A      | 9    | 10               | 175  | 120  |
| B      | 8    | 7                | 164  | 80   |
| C      | 6    | 3                | 157  | 90   |

> å…¶ä¸­é¢œå€¼ä¸ºæå¤§å‹æŒ‡æ ‡ï¼Œè„¾æ°”æå°å‹æŒ‡æ ‡ï¼Œèº«é«˜ä¸­é—´å‹æŒ‡æ ‡(165)ï¼Œä½“é‡åŒºé—´å‹æŒ‡æ ‡ï¼ˆ90-100ï¼‰

æ­£å‘åŒ–

| å€™é€‰äºº | é¢œå€¼ | è„¾æ°”ï¼ˆäº‰åµæ¬¡æ•°ï¼‰ | èº«é«˜ | ä½“é‡ |
| ------ | ---- | ---------------- | ---- | ---- |
| A      | 9    | 0                | 0    | 0    |
| B      | 8    | 3                | 0.9  | 0.5  |
| C      | 6    | 7                | 0.2  | 1    |

æ ‡å‡†åŒ–

| å€™é€‰äºº | é¢œå€¼  | è„¾æ°”ï¼ˆäº‰åµæ¬¡æ•°ï¼‰ | èº«é«˜  | ä½“é‡  |
| ------ | ----- | ---------------- | ----- | ----- |
| A      | 0.669 | 0.000            | 0.000 | 0.000 |
| B      | 0.595 | 0.394            | 0.976 | 0.447 |
| C      | 0.446 | 0.919            | 0.217 | 0.894 |

ç†µæƒæ³•è®¡ç®—æƒé‡

| é¢œå€¼  | è„¾æ°”ï¼ˆäº‰åµæ¬¡æ•°ï¼‰ | èº«é«˜  | ä½“é‡  |
| ----- | ---------------- | ----- | ----- |
| 0.008 | 0.307            | 0.393 | 0.291 |

åŠ æƒåçŸ©é˜µ

| å€™é€‰äºº | é¢œå€¼   | è„¾æ°”   | èº«é«˜   | ä½“é‡   |
| ------ | ------ | ------ | ------ | ------ |
| A      | 0.0057 | 0.0000 | 0.0000 | 0.0000 |
| B      | 0.0051 | 0.1210 | 0.3839 | 0.1301 |
| C      | 0.0038 | 0.2823 | 0.0853 | 0.2603 |

ç¡®å®šæ­£ç†æƒ³è§£ä¸è´Ÿç†æƒ³è§£ï¼š

| å±æ€§ | Z+ (æœ€å¤§) | Z- (æœ€å°) |
| ---- | --------- | --------- |
| é¢œå€¼ | 0.0057    | 0.0038    |
| è„¾æ°” | 0.2823    | 0.0000    |
| èº«é«˜ | 0.3839    | 0.0000    |
| ä½“é‡ | 0.2603    | 0.0000    |

**æ­£ç†æƒ³è§£ Z+**: `[0.0057, 0.2823, 0.3839, 0.2603]` 
**è´Ÿç†æƒ³è§£ Z-**: `[0.0038, 0.0000, 0.0000, 0.0000]`

è®¡ç®—å„æ–¹æ¡ˆåˆ°ç†æƒ³è§£çš„è·ç¦»

| å€™é€‰äºº | D+     | D-     |
| ------ | ------ | ------ |
| A      | 0.5430 | 0.0019 |
| B      | 0.2073 | 0.4230 |
| C      | 0.2986 | 0.3934 |

è®¡ç®—è´´è¿‘åº¦ï¼ˆæœ€ç»ˆå¾—åˆ†ï¼‰

| å€™é€‰äºº | å¾—åˆ†   |
| ------ | ------ |
| A      | 0.0035 |
| B      | 0.6711 |
| C      | 0.5685 |

å½’ä¸€åŒ–æ¢æˆç™¾åˆ†åˆ¶

| å€™é€‰äºº | å¾—åˆ†   |
| ------ | ------ |
| B      | 53.99% |
| C      | 45.73% |
| A      | 0.28%  |

### ç¤ºä¾‹ä»£ç 

```python
import numpy as np
import matplotlib.pyplot as plt

def topsis(decision_matrix, weights, criteria_specs, alternatives_labels):
    """
    Advanced TOPSIS method that handles multiple criteria types and prints intermediate steps.

    Args:
        decision_matrix (np.ndarray): A 2D numpy array of the decision matrix.
                                      Rows are alternatives, columns are criteria.
        weights (np.ndarray): A 1D numpy array of weights for each criterion.
        criteria_specs (list): A list of tuples specifying the type and parameters for each criterion.
        alternatives_labels (list): A list of strings for labeling the alternatives.

    Returns:
        tuple: A tuple containing:
            - np.ndarray: The closeness coefficient (Si) for each alternative.
            - np.ndarray: The rank of each alternative.
    """
    # Step 1: Forwardization (Convert all criteria to benefit type)
    positive_matrix = np.zeros_like(decision_matrix, dtype=float)

    for i, spec in enumerate(criteria_specs):
        col = decision_matrix[:, i]
        criterion_type = spec[0]

        if criterion_type == 'benefit':
            positive_matrix[:, i] = col
        elif criterion_type == 'cost':
            positive_matrix[:, i] = np.max(col) - col
        elif criterion_type == 'mid':
            best_value = spec[1]
            m = np.max(np.abs(col - best_value))
            if m == 0:
                positive_matrix[:, i] = 1.0
            else:
                positive_matrix[:, i] = 1 - (np.abs(col - best_value) / m)
        elif criterion_type == 'interval':
            lower_bound, upper_bound = spec[1], spec[2]
            m = np.max([lower_bound - np.min(col), np.max(col) - upper_bound])
            transformed_col = np.zeros_like(col, dtype=float)
            if m == 0:
                 for j, val in enumerate(col):
                    if lower_bound <= val <= upper_bound:
                        transformed_col[j] = 1
                    else:
                        transformed_col[j] = 0
            else:
                for j, val in enumerate(col):
                    if val < lower_bound:
                        transformed_col[j] = 1 - (lower_bound - val) / m
                    elif val > upper_bound:
                        transformed_col[j] = 1 - (val - upper_bound) / m
                    else:
                        transformed_col[j] = 1
            positive_matrix[:, i] = transformed_col
        else:
            raise ValueError(f"Unknown criterion type: {criterion_type}")

    # Step 2: Normalize the positive decision matrix
    norm_matrix = positive_matrix / np.sqrt(np.sum(positive_matrix ** 2, axis=0))

    # Step 3: Calculate weights using Entropy Weight Method if not provided
    if weights is None:
        # Calculate probability matrix
        prob_matrix = norm_matrix / np.sum(norm_matrix, axis=0, keepdims=True)

        # Calculate entropy for each criterion
        entropy = np.zeros(prob_matrix.shape[1])
        for j in range(prob_matrix.shape[1]):
            for i in range(prob_matrix.shape[0]):
                if prob_matrix[i, j] == 0:
                    continue
                entropy[j] += prob_matrix[i, j] * np.log(prob_matrix[i, j])
        entropy = -entropy / np.log(norm_matrix.shape[0])

        # Calculate redundancy (utility) for each criterion
        redundancy = 1 - entropy

        # Calculate weights for each criterion
        weights = redundancy / np.sum(redundancy)

    # Step 4: Create the weighted normalized decision matrix
    weighted_matrix = norm_matrix * weights

    print("--- Intermediate Steps ---")
    print("\nStep 1: Forwardized Matrix (Positive Matrix):\n", positive_matrix)
    print("\nStep 2: Normalized Matrix:\n", norm_matrix)
    print("\nStep 3: Calculated Weights (or provided weights):\n", weights)
    print("\nStep 4: Weighted Normalized Matrix:\n", weighted_matrix)
    print("\n" + "=" * 50 + "\n")

    # Step 5: Determine the ideal and negative-ideal solutions
    ideal_solution = np.max(weighted_matrix, axis=0)  # Z+
    negative_ideal_solution = np.min(weighted_matrix, axis=0)  # Z-

    print("--- Ideal and Negative-Ideal Solutions ---")
    print("\nIdeal Solution (Z+):\n", ideal_solution)
    print("\nNegative-Ideal Solution (Z-):\n", negative_ideal_solution)
    print("Ideal Solution (Z+):")
    print(ideal_solution)
    print("\nNegative-Ideal Solution (Z-):")
    print(negative_ideal_solution)
    print("\n" + "="*50 + "\n")


    print("--- Intermediate Step 5: Distances to Ideal Solutions ---")
    # Step 5: Calculate the separation measures
    distance_to_ideal = np.sqrt(np.sum((weighted_matrix - ideal_solution)**2, axis=1))
    distance_to_negative_ideal = np.sqrt(np.sum((weighted_matrix - negative_ideal_solution)**2, axis=1))
    for i, label in enumerate(alternatives_labels):
        print(f"{label} -> Distance to Ideal (D+): {distance_to_ideal[i]:.4f}, Distance to Negative-Ideal (D-): {distance_to_negative_ideal[i]:.4f}")
    print("\n" + "="*50 + "\n")

    # Step 6: Calculate the relative closeness to the ideal solution
    epsilon = 1e-6
    closeness_coefficient = distance_to_negative_ideal / (distance_to_ideal + distance_to_negative_ideal + epsilon)

    # Step 7: Rank the alternatives
    rank = len(closeness_coefficient) - np.argsort(np.argsort(closeness_coefficient))

    return closeness_coefficient, rank

if __name__ == '__main__':
    # --- Example Usage: Candidate Selection ---

    # Alternatives: Candidate A, Candidate B, Candidate C
    alternatives = [f'Candidate {chr(65+i)}' for i in range(3)]

    # Criteria:
    # 1. Appearance (Score) - 'benefit' type
    # 2. Temper (Number of quarrels) - 'cost' type
    # 3. Height (cm) - 'mid' type (best is 165cm)
    # 4. Weight (kg) - 'interval' type (best is between 90-100kg)
    decision_matrix = np.array([
    # Appearance, Temper, Height, Weight
        [9, 10, 175, 120],  # Candidate A
        [8,  7, 164,  80],  # Candidate B
        [6,  3, 157,  90],  # Candidate C
    ])

    # Weights for each criterion. Assuming equal importance.
    weights = None # Use None to calculate weights using entropy method

    # Specifications for each criterion
    criteria_specs = [
        ('benefit',),
        ('cost',),
        ('mid', 165),
        ('interval', 90, 100)
    ]

    # --- Run TOPSIS ---
    closeness_coefficient, rank = topsis(decision_matrix, weights, criteria_specs, alternatives)

    # --- Final Results ---
    print("--- Final Results ---")
    print(f"{'Alternative':<12} | {'Closeness (Si)':<15} | {'Rank':<5}")
    print("-" * 40)
    results_to_display = sorted(zip(alternatives, closeness_coefficient, rank), key=lambda x: x[2])
    for alt, closeness, r in results_to_display:
        print(f"{alt:<12} | {closeness:<15.4f} | {r:<5}")

    # Calculate percentage score
    percentage_score = (closeness_coefficient / np.sum(closeness_coefficient)) * 100
    print("\n--- Final Percentage Scores (Normalized) ---")
    print(f"{'Alternative':<12} | {'Percentage Score':<20}")
    print("-" * 40)
    results_to_display_percent = sorted(zip(alternatives, percentage_score, rank), key=lambda x: x[2])
    for alt, percent_score, r in results_to_display_percent:
        print(f"{alt:<12} | {percent_score:<20.2f}%")

    best_alternative_index = np.argmax(closeness_coefficient)
    print(f"\nBest Alternative based on TOPSIS: {alternatives[best_alternative_index]}")

    # --- Visualize the Results ---
    plt.figure(figsize=(10, 6))
    sorted_indices = np.argsort(rank)
    sorted_alternatives = [alternatives[i] for i in sorted_indices]
    sorted_closeness = closeness_coefficient[sorted_indices]

    bars = plt.bar(sorted_alternatives, sorted_closeness, color='teal')
    plt.xlabel('Alternatives (Sorted by Rank)')
    plt.ylabel('Closeness Coefficient (Si)')
    plt.title('TOPSIS Results: Closeness Coefficient of Candidates')
    plt.ylim(0, max(closeness_coefficient) * 1.2)

    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2.0, yval, f'{yval:.4f}', va='bottom', ha='center')

    plt.tight_layout()
    plt.show()
```