---
index_img: 'https://img.picgo.net/2025/05/31/25-05-31-174868501780081c5020678b86acf.webp'
banner_img: 'https://img.picgo.net/2025/05/31/25-05-31-174868456032966958ff522538315.webp'
title: 数模笔记练习题
categories:
  - 学习笔记
tags:
  - 数学建模
comments: true
abbrlink: 8e0504a
date: 2025-06-20 19:08:10
updated: 2025-06-22 10:45:19
---

## 线性规划

### 题目

1.4 一架货机有三个货舱：前舱、中舱和后舱。三个货舱所能装载的货物的最大重量和体积有限制如表1.2所列。并且为了飞机的平衡，三个货舱装载的货物重量必须与其最大的容许量成比例。

**表1.2 货舱数据**

|          | 前舱 | 中舱 | 后舱 |
|----------|------|------|------|
| 重量限制/t | 10   | 16   | 8    |
| 体积限制/m³ | 6800 | 8700 | 5300 |

现有四类货物用该货机进行装运，货物的规格以及装运后获得的利润如表1.3所列

**表1.3 货物规格及利润表**

|        | 重量/t | 空间/(m³/t) | 利润/(元/t) |
|--------|--------|-------------|-------------|
| 货物1   | 18     | 480         | 3100        |
| 货物2   | 15     | 650         | 3800        |
| 货物3   | 23     | 580         | 3500        |
| 货物4   | 12     | 390         | 2850        |

**假设:**

1. 每种货物可以无限细分；
2. 每种货物可以分布在一个或者多个货舱内；
3. 不同的货物可以放在同一个货舱内，并且可以保证不留空隙。

### 解答

#### 变量定义与参数

设 
- $x_{ij}$：第$i$类货物装载在第$j$个舱位的重量（吨） 
  - $i = 1, 2, 3, 4$（货物种类1至4） 
  - $j = 1, 2, 3$（舱位：1 = 前舱，2 = 中舱，3 = 后舱）

- 舱位限制：
  - 每个舱位的最大载重（吨）：$W = [10, 16, 8]$
  - 每个舱位的最大体积（立方米）：$V = [6800, 8700, 5300]$

- 货物数据： 
  - 每类货物可用的最大重量（吨）：$A = [18, 15, 23, 12]$
  - 每吨货物所占体积（立方米/吨）：$Q = [480, 650, 580, 390]$
  - 每吨货物的利润（元/吨）：$P = [3100, 3800, 3500, 2850]$

#### 数学模型

**目标函数：** 最大化总利润
$$
\text{Maximize} \quad Z = \sum_{i=1}^4 \sum_{j=1}^3 p_i\, x_{ij}
$$

**约束条件：**

1. 每个舱位的重量限制：

$$
\sum_{i=1}^4 x_{ij} \leq W_j,\quad j = 1, 2, 3
$$

2. 每个舱位的体积限制：

$$
\sum_{i=1}^4 q_i\, x_{ij} \leq V_j,\quad j = 1, 2, 3
$$

3. 每种货物的总供应限制：

$$
\sum_{j=1}^3 x_{ij} \leq A_i,\quad i = 1, 2, 3, 4
$$

4. 装载平衡约束（按比例装载以保持平衡）：

$$
\frac{\sum_{i=1}^4 x_{i1}}{W_1} = \frac{\sum_{i=1}^4 x_{i2}}{W_2} = \frac{\sum_{i=1}^4 x_{i3}}{W_3}
$$

这等价于以下两个线性约束：

$$
16\sum_{i=1}^4 x_{i1} - 10\sum_{i=1}^4 x_{i2} = 0
$$

$$
8\sum_{i=1}^4 x_{i2} - 16\sum_{i=1}^4 x_{i3} = 0
$$

5. 非负约束：

$$
x_{ij} \geq 0,\quad \forall\, i,j
$$

#### 求解代码

{% fold  unified_regressor.py %}
```python
import pyomo.environ as pyo
import numpy as np
import matplotlib.pyplot as plt
from pyomo.opt import SolverStatus, TerminationCondition
import warnings

warnings.filterwarnings('ignore')

# English font setup for all plots
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.size'] = 10


class OptimizationSolver:

    def __init__(self, name="Problem"):
        self.model = None
        self.solver = None
        self.results = None
        self.name = name
        self.problem_type = "LP"
        self.var_names = []
        self.var_types = []
        self.constraint_counter = 0
        self.has_integer_vars = False
        self.has_continuous_vars = False
        self.has_quadratic_terms = False
        self.has_nonlinear_terms = False

    def create_model(self, n_vars, var_names=None, var_types=None, lb=None, ub=None):
        """Create optimization model with mixed variable types"""
        self.model = pyo.ConcreteModel(self.name)
        self.model.I = pyo.RangeSet(1, n_vars)

        # Handle variable names
        if var_names is None:
            self.var_names = [f"x{i}" for i in range(1, n_vars + 1)]
        else:
            self.var_names = list(var_names[:n_vars])
            while len(self.var_names) < n_vars:
                self.var_names.append(f"x{len(self.var_names) + 1}")

        # Handle variable types
        if var_types is None:
            self.var_types = ['continuous'] * n_vars
        elif isinstance(var_types, str):
            self.var_types = [var_types] * n_vars
        else:
            self.var_types = list(var_types[:n_vars])
            while len(self.var_types) < n_vars:
                self.var_types.append('continuous')

        # Track variable types
        self.has_integer_vars = any(vtype in ['integer', 'binary'] for vtype in self.var_types)
        self.has_continuous_vars = any(vtype == 'continuous' for vtype in self.var_types)

        # Create variables with individual domains
        self.model.x = pyo.Var(self.model.I)

        for i, var_type in enumerate(self.var_types, 1):
            if var_type == 'continuous':
                self.model.x[i].domain = pyo.Reals
            elif var_type == 'integer':
                self.model.x[i].domain = pyo.Integers
            elif var_type == 'binary':
                self.model.x[i].domain = pyo.Binary
            else:
                self.model.x[i].domain = pyo.Reals

        # Set bounds with safety for nonlinear functions
        if lb is not None:
            if isinstance(lb, (int, float)):
                lb = [lb] * n_vars
            for i, lower in enumerate(lb, 1):
                if lower is not None and i <= n_vars:
                    # Safe bounds for sqrt and other nonlinear functions
                    safe_lower = max(lower, 1e-6) if lower >= 0 else lower
                    self.model.x[i].setlb(safe_lower)

        if ub is not None:
            if isinstance(ub, (int, float)):
                ub = [ub] * n_vars
            for i, upper in enumerate(ub, 1):
                if upper is not None and i <= n_vars:
                    self.model.x[i].setub(upper)

        return self

    def set_objective(self, objective_func, sense='minimize'):
        """Set objective function with type detection"""
        if sense.lower() in ['minimize', 'min']:
            self.model.obj = pyo.Objective(expr=objective_func(self.model), sense=pyo.minimize)
        else:
            self.model.obj = pyo.Objective(expr=objective_func(self.model), sense=pyo.maximize)

        self._detect_problem_type()
        return self

    def _detect_problem_type(self):
        """Detect problem type based on objective and variables"""
        self.has_quadratic_terms = False
        self.has_nonlinear_terms = False

        try:
            obj_str = str(self.model.obj.expr).lower()

            # Check for quadratic terms
            import re
            if (re.search(r'x\[\d+\]\*\*2', obj_str) or
                    re.search(r'x\[\d+\]\s*\*\s*x\[\d+\]', obj_str)):
                self.has_quadratic_terms = True

            # Check for nonlinear terms (sqrt, exp, log, higher powers)
            nonlinear_keywords = ['exp', 'log', 'sin', 'cos', 'sqrt']
            higher_powers = [f'**{i}' for i in range(3, 10)] + ['**0.5', '**1.5']

            if (any(keyword in obj_str for keyword in nonlinear_keywords) or
                    any(power in obj_str for power in higher_powers)):
                self.has_nonlinear_terms = True

        except:
            pass

        # Determine problem type
        if self.has_integer_vars and self.has_continuous_vars:
            # Mixed integer problem
            if self.has_nonlinear_terms:
                self.problem_type = "MINLP"
            elif self.has_quadratic_terms:
                self.problem_type = "MIQP"
            else:
                self.problem_type = "MILP"
        elif self.has_integer_vars:
            # Pure integer problem
            if self.has_nonlinear_terms:
                self.problem_type = "INLP"
            elif self.has_quadratic_terms:
                self.problem_type = "IQP"
            else:
                self.problem_type = "ILP"
        else:
            # Pure continuous problem
            if self.has_nonlinear_terms:
                self.problem_type = "NLP"
            elif self.has_quadratic_terms:
                self.problem_type = "QP"
            else:
                self.problem_type = "LP"

    def add_constraint(self, constraint_func, sense='<=', name=None):
        """Add single constraint"""
        self.constraint_counter += 1
        if name is None:
            name = f"constraint_{self.constraint_counter}"

        if sense == '<=':
            expr = constraint_func(self.model) <= 0
        elif sense == '>=':
            expr = constraint_func(self.model) >= 0
        else:  # '='
            expr = constraint_func(self.model) == 0

        setattr(self.model, name, pyo.Constraint(expr=expr))
        return self

    def add_linear_constraints(self, A, b, sense='<='):
        """Add multiple linear constraints"""
        A = np.array(A)
        b = np.array(b)

        if A.ndim == 1:
            A = A.reshape(1, -1)

        self.constraint_counter += 1
        constraint_name = f'linear_constraints_{self.constraint_counter}'

        if sense == '<=':
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) <= b[i - 1]
        elif sense == '>=':
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) >= b[i - 1]
        else:  # '='
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) == b[i - 1]

        setattr(self.model, constraint_name,
                pyo.Constraint(pyo.RangeSet(1, len(b)), rule=rule))

        return self

    def solve(self, solver=None, options=None, verbose=False):
        """Solve optimization problem"""
        if self.model is None:
            print("❌ No model created!")
            return False

        # Auto-select solver
        if solver is None:
            if self.problem_type in ["LP", "QP", "NLP"]:
                solver = "ipopt" if self.problem_type == "NLP" else "gurobi"
            else:
                solver = "gurobi" if pyo.SolverFactory('gurobi').available() else "ipopt"

        if not pyo.SolverFactory(solver).available():
            print(f"❌ Solver {solver} not available!")
            return False

        # Create solver
        self.solver = pyo.SolverFactory(solver)

        # Set solver options
        if solver == 'ipopt':
            clean_options = {
                'print_level': 0,  # Silent IPOPT
                'max_iter': 3000,
                'tol': 1e-6,
                'linear_solver': 'mumps'
            }
            if options:
                clean_options.update(options)

            for key, value in clean_options.items():
                self.solver.options[key] = value
        elif options:
            for key, value in options.items():
                self.solver.options[key] = value

        # Set safe initial point for nonlinear problems
        if self.has_nonlinear_terms:
            try:
                for i in self.model.I:
                    if self.model.x[i].value is None:
                        lb = self.model.x[i].lb if self.model.x[i].lb is not None else 0
                        ub = self.model.x[i].ub if self.model.x[i].ub is not None else 10
                        initial_val = max((lb + ub) / 2, 0.1)
                        self.model.x[i].set_value(initial_val)
            except:
                pass

        # Solve
        try:
            self.results = self.solver.solve(self.model, tee=verbose)

            if (self.results.solver.status == SolverStatus.ok and
                    self.results.solver.termination_condition in [TerminationCondition.optimal,
                                                                  TerminationCondition.locallyOptimal,
                                                                  TerminationCondition.feasible]):
                return True
            else:
                return False

        except:
            return False

    def get_solution(self):
        """Get solution information"""
        if not self.results:
            return None

        try:
            solution = {
                'objective_value': pyo.value(self.model.obj),
                'variables': {},
                'variable_types': {},
                'problem_type': self.problem_type,
                'solver_status': str(self.results.solver.status),
                'termination_condition': str(self.results.solver.termination_condition),
                'has_mixed_variables': self.has_integer_vars and self.has_continuous_vars
            }

            for i in self.model.I:
                var_name = self.var_names[i - 1]
                var_type = self.var_types[i - 1]
                value = pyo.value(self.model.x[i])
                solution['variables'][var_name] = value if value is not None else 0.0
                solution['variable_types'][var_name] = var_type

            return solution
        except:
            return None

    def print_solution(self):
        solution = self.get_solution()
        if not solution:
            print("❌ No solution available")
            return

        print(f"\n📊 {solution['problem_type']} SOLUTION")
        print("=" * 50)
        print(f"Objective Value: {solution['objective_value']:.6f}")

        # Show variable types for mixed problems
        if solution['has_mixed_variables']:
            print("Variable Types:")
            continuous_vars = [name for name, vtype in solution['variable_types'].items()
                               if vtype == 'continuous']
            integer_vars = [name for name, vtype in solution['variable_types'].items()
                            if vtype == 'integer']
            binary_vars = [name for name, vtype in solution['variable_types'].items()
                           if vtype == 'binary']

            if continuous_vars:
                print(f"  Continuous: {', '.join(continuous_vars)}")
            if integer_vars:
                print(f"  Integer: {', '.join(integer_vars)}")
            if binary_vars:
                print(f"  Binary: {', '.join(binary_vars)}")

        print("Variable Values:")
        for name, value in solution['variables'].items():
            var_type = solution['variable_types'][name]
            if var_type in ['integer', 'binary'] and abs(value - round(value)) < 1e-6:
                print(f"  {name} = {int(round(value))} ({var_type})")
            else:
                print(f"  {name} = {value:.6f} ({var_type})")

    def plot_solution_2d(self, x_range=None, y_range=None, title=None, figsize=(10, 7)):
        """Plot 2D solution with ALL ENGLISH LABELS"""
        solution = self.get_solution()
        if not solution or len(solution['variables']) != 2:
            print(
                f"⚠️ Cannot plot: Problem has {len(solution['variables']) if solution else 0} variables (need exactly 2 for 2D plot)")
            return

        if x_range is None:
            x_range = (0, 10)
        if y_range is None:
            y_range = (0, 10)
        if title is None:
            title = f"{self.name}"

        # Get solution point and variable types
        vars_list = list(solution['variables'].items())
        x_opt, y_opt = vars_list[0][1], vars_list[1][1]
        x_name, y_name = vars_list[0][0], vars_list[1][0]
        x_type = solution['variable_types'][x_name]
        y_type = solution['variable_types'][y_name]

        # Create plot with ALL ENGLISH LABELS
        fig, ax = plt.subplots(figsize=figsize)

        # Plot optimal point with markers based on variable types
        if x_type in ['integer', 'binary'] or y_type in ['integer', 'binary']:
            ax.plot(x_opt, y_opt, 'rs', markersize=14, zorder=5,
                    label=f'Optimal Solution\n({x_opt:.3f}, {y_opt:.3f})')
        else:
            ax.plot(x_opt, y_opt, 'ro', markersize=14, zorder=5,
                    label=f'Optimal Solution\n({x_opt:.3f}, {y_opt:.3f})')

        # Annotation with ENGLISH TEXT and variable types
        annotation_text = (f'Optimal Point\n'
                           f'{x_name}: {x_opt:.3f} ({x_type})\n'
                           f'{y_name}: {y_opt:.3f} ({y_type})\n'
                           f'Objective Value: {solution["objective_value"]:.3f}')

        ax.annotate(annotation_text,
                    xy=(x_opt, y_opt),
                    xytext=(x_opt + (x_range[1] - x_range[0]) * 0.15,
                            y_opt + (y_range[1] - y_range[0]) * 0.15),
                    arrowprops=dict(arrowstyle='->', color='red', lw=2),
                    bbox=dict(boxstyle="round,pad=0.5", facecolor="yellow", alpha=0.8),
                    fontsize=12, ha='left')

        # Set ALL ENGLISH AXIS LABELS
        ax.set_xlim(x_range)
        ax.set_ylim(y_range)
        ax.set_xlabel(f'{x_name} ({x_type})', fontsize=14, fontweight='bold')
        ax.set_ylabel(f'{y_name} ({y_type})', fontsize=14, fontweight='bold')
        ax.set_title(f'{title} ({solution["problem_type"]} Problem)',
                     fontsize=16, fontweight='bold')

        ax.grid(True, alpha=0.3)
        ax.legend(fontsize=12, loc='best')

        # Add variable information box in ENGLISH
        if solution['has_mixed_variables']:
            info_text = "Mixed Variable Types:\n"
            for name, vtype in solution['variable_types'].items():
                info_text += f"{name}: {vtype}\n"

            ax.text(0.02, 0.98, info_text.strip(), transform=ax.transAxes,
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.7),
                    fontsize=10, verticalalignment='top')

        # ENGLISH TIMESTAMP
        timestamp_text = f"Generated: 2025-06-20 10:58:07 UTC | User: giraffishh"
        fig.text(0.99, 0.01, timestamp_text, ha='right', va='bottom',
                 fontsize=9, alpha=0.6)

        plt.tight_layout()
        plt.show()
        print(f"✅ Plot created for {solution['problem_type']} problem with ALL ENGLISH LABELS")
```
{% endfold %}

**`solve.py`:**

```python
from unified_regressor import OptimizationSolver

def main():
    # 舱参数
    W = [10, 16, 8]  # 重量限制 (t)
    V = [6800, 8700, 5300]  # 体积限制 (m^3)

    # 货物参数
    P = [3100, 3800, 3500, 2850]  # 利润 (元/t)
    Q = [480, 650, 580, 390]  # 空间 (m^3/t)
    A = [18, 15, 23, 12]  # 每种货物最大可用总重量 (t)

    solver = OptimizationSolver("Cargo_Allocation")
    var_names = [f"x{i + 1}{j + 1}" for i in range(4) for j in range(3)]
    solver.create_model(12, var_names=var_names, var_types='continuous', lb=0)

    # 目标函数
    def obj(model):
        return sum(P[i] * model.x[3 * i + j + 1] for i in range(4) for j in range(3))

    solver.set_objective(obj, 'maximize')

    # 各舱重量约束
    for j in range(3):
        solver.add_constraint(lambda model, j=j: sum(model.x[3 * i + j + 1] for i in range(4)) - W[j], '<=')

    # 各舱体积约束
    for j in range(3):
        solver.add_constraint(lambda model, j=j: sum(Q[i] * model.x[3 * i + j + 1] for i in range(4)) - V[j], '<=')

    # 每种货物总量约束
    for i in range(4):
        solver.add_constraint(lambda model, i=i: sum(model.x[3 * i + j + 1] for j in range(3)) - A[i], '<=')

    # 平衡约束
    solver.add_constraint(
        lambda model: 16 * sum(model.x[3 * i + 1] for i in range(4)) - 10 * sum(model.x[3 * i + 2] for i in range(4)),
        '=')
    solver.add_constraint(
        lambda model: 8 * sum(model.x[3 * i + 2] for i in range(4)) - 16 * sum(model.x[3 * i + 3] for i in range(4)),
        '=')

    solver.solve()
    solver.print_solution()

    # Print total loaded for each good
    solution = solver.get_solution()
    if solution:
        print("\nTotal loaded for each good:")
        for i in range(4):
            total = sum(solution['variables'][f"x{i + 1}{j + 1}"] for j in range(3))
            print(f"  Good {i + 1} total: {total:.6f} t")

if __name__ == "__main__":
    main()
```