---
index_img: 'https://img.picgo.net/2025/05/31/25-05-31-174868501780081c5020678b86acf.webp'
banner_img: 'https://img.picgo.net/2025/05/31/25-05-31-174868456032966958ff522538315.webp'
title: æ•°æ¨¡ç¬”è®°ç»ƒä¹ é¢˜
categories:
  - å­¦ä¹ ç¬”è®°
tags:
  - æ•°å­¦å»ºæ¨¡
comments: true
abbrlink: 8e0504a
date: 2025-06-20 19:08:10
updated: 2025-06-22 10:45:19
---

## çº¿æ€§è§„åˆ’

### é¢˜ç›®

1.4 ä¸€æ¶è´§æœºæœ‰ä¸‰ä¸ªè´§èˆ±ï¼šå‰èˆ±ã€ä¸­èˆ±å’Œåèˆ±ã€‚ä¸‰ä¸ªè´§èˆ±æ‰€èƒ½è£…è½½çš„è´§ç‰©çš„æœ€å¤§é‡é‡å’Œä½“ç§¯æœ‰é™åˆ¶å¦‚è¡¨1.2æ‰€åˆ—ã€‚å¹¶ä¸”ä¸ºäº†é£æœºçš„å¹³è¡¡ï¼Œä¸‰ä¸ªè´§èˆ±è£…è½½çš„è´§ç‰©é‡é‡å¿…é¡»ä¸å…¶æœ€å¤§çš„å®¹è®¸é‡æˆæ¯”ä¾‹ã€‚

**è¡¨1.2 è´§èˆ±æ•°æ®**

|          | å‰èˆ± | ä¸­èˆ± | åèˆ± |
|----------|------|------|------|
| é‡é‡é™åˆ¶/t | 10   | 16   | 8    |
| ä½“ç§¯é™åˆ¶/mÂ³ | 6800 | 8700 | 5300 |

ç°æœ‰å››ç±»è´§ç‰©ç”¨è¯¥è´§æœºè¿›è¡Œè£…è¿ï¼Œè´§ç‰©çš„è§„æ ¼ä»¥åŠè£…è¿åè·å¾—çš„åˆ©æ¶¦å¦‚è¡¨1.3æ‰€åˆ—

**è¡¨1.3 è´§ç‰©è§„æ ¼åŠåˆ©æ¶¦è¡¨**

|        | é‡é‡/t | ç©ºé—´/(mÂ³/t) | åˆ©æ¶¦/(å…ƒ/t) |
|--------|--------|-------------|-------------|
| è´§ç‰©1   | 18     | 480         | 3100        |
| è´§ç‰©2   | 15     | 650         | 3800        |
| è´§ç‰©3   | 23     | 580         | 3500        |
| è´§ç‰©4   | 12     | 390         | 2850        |

**å‡è®¾:**

1. æ¯ç§è´§ç‰©å¯ä»¥æ— é™ç»†åˆ†ï¼›
2. æ¯ç§è´§ç‰©å¯ä»¥åˆ†å¸ƒåœ¨ä¸€ä¸ªæˆ–è€…å¤šä¸ªè´§èˆ±å†…ï¼›
3. ä¸åŒçš„è´§ç‰©å¯ä»¥æ”¾åœ¨åŒä¸€ä¸ªè´§èˆ±å†…ï¼Œå¹¶ä¸”å¯ä»¥ä¿è¯ä¸ç•™ç©ºéš™ã€‚

### è§£ç­”

#### å˜é‡å®šä¹‰ä¸å‚æ•°

è®¾ 
- $x_{ij}$ï¼šç¬¬$i$ç±»è´§ç‰©è£…è½½åœ¨ç¬¬$j$ä¸ªèˆ±ä½çš„é‡é‡ï¼ˆå¨ï¼‰ 
  - $i = 1, 2, 3, 4$ï¼ˆè´§ç‰©ç§ç±»1è‡³4ï¼‰ 
  - $j = 1, 2, 3$ï¼ˆèˆ±ä½ï¼š1 = å‰èˆ±ï¼Œ2 = ä¸­èˆ±ï¼Œ3 = åèˆ±ï¼‰

- èˆ±ä½é™åˆ¶ï¼š
  - æ¯ä¸ªèˆ±ä½çš„æœ€å¤§è½½é‡ï¼ˆå¨ï¼‰ï¼š$W = [10, 16, 8]$
  - æ¯ä¸ªèˆ±ä½çš„æœ€å¤§ä½“ç§¯ï¼ˆç«‹æ–¹ç±³ï¼‰ï¼š$V = [6800, 8700, 5300]$

- è´§ç‰©æ•°æ®ï¼š 
  - æ¯ç±»è´§ç‰©å¯ç”¨çš„æœ€å¤§é‡é‡ï¼ˆå¨ï¼‰ï¼š$A = [18, 15, 23, 12]$
  - æ¯å¨è´§ç‰©æ‰€å ä½“ç§¯ï¼ˆç«‹æ–¹ç±³/å¨ï¼‰ï¼š$Q = [480, 650, 580, 390]$
  - æ¯å¨è´§ç‰©çš„åˆ©æ¶¦ï¼ˆå…ƒ/å¨ï¼‰ï¼š$P = [3100, 3800, 3500, 2850]$

#### æ•°å­¦æ¨¡å‹

**ç›®æ ‡å‡½æ•°ï¼š** æœ€å¤§åŒ–æ€»åˆ©æ¶¦
$$
\text{Maximize} \quad Z = \sum_{i=1}^4 \sum_{j=1}^3 p_i\, x_{ij}
$$

**çº¦æŸæ¡ä»¶ï¼š**

1. æ¯ä¸ªèˆ±ä½çš„é‡é‡é™åˆ¶ï¼š

$$
\sum_{i=1}^4 x_{ij} \leq W_j,\quad j = 1, 2, 3
$$

2. æ¯ä¸ªèˆ±ä½çš„ä½“ç§¯é™åˆ¶ï¼š

$$
\sum_{i=1}^4 q_i\, x_{ij} \leq V_j,\quad j = 1, 2, 3
$$

3. æ¯ç§è´§ç‰©çš„æ€»ä¾›åº”é™åˆ¶ï¼š

$$
\sum_{j=1}^3 x_{ij} \leq A_i,\quad i = 1, 2, 3, 4
$$

4. è£…è½½å¹³è¡¡çº¦æŸï¼ˆæŒ‰æ¯”ä¾‹è£…è½½ä»¥ä¿æŒå¹³è¡¡ï¼‰ï¼š

$$
\frac{\sum_{i=1}^4 x_{i1}}{W_1} = \frac{\sum_{i=1}^4 x_{i2}}{W_2} = \frac{\sum_{i=1}^4 x_{i3}}{W_3}
$$

è¿™ç­‰ä»·äºä»¥ä¸‹ä¸¤ä¸ªçº¿æ€§çº¦æŸï¼š

$$
16\sum_{i=1}^4 x_{i1} - 10\sum_{i=1}^4 x_{i2} = 0
$$

$$
8\sum_{i=1}^4 x_{i2} - 16\sum_{i=1}^4 x_{i3} = 0
$$

5. éè´Ÿçº¦æŸï¼š

$$
x_{ij} \geq 0,\quad \forall\, i,j
$$

#### æ±‚è§£ä»£ç 

{% fold  unified_regressor.py %}
```python
import pyomo.environ as pyo
import numpy as np
import matplotlib.pyplot as plt
from pyomo.opt import SolverStatus, TerminationCondition
import warnings

warnings.filterwarnings('ignore')

# English font setup for all plots
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.size'] = 10


class OptimizationSolver:

    def __init__(self, name="Problem"):
        self.model = None
        self.solver = None
        self.results = None
        self.name = name
        self.problem_type = "LP"
        self.var_names = []
        self.var_types = []
        self.constraint_counter = 0
        self.has_integer_vars = False
        self.has_continuous_vars = False
        self.has_quadratic_terms = False
        self.has_nonlinear_terms = False

    def create_model(self, n_vars, var_names=None, var_types=None, lb=None, ub=None):
        """Create optimization model with mixed variable types"""
        self.model = pyo.ConcreteModel(self.name)
        self.model.I = pyo.RangeSet(1, n_vars)

        # Handle variable names
        if var_names is None:
            self.var_names = [f"x{i}" for i in range(1, n_vars + 1)]
        else:
            self.var_names = list(var_names[:n_vars])
            while len(self.var_names) < n_vars:
                self.var_names.append(f"x{len(self.var_names) + 1}")

        # Handle variable types
        if var_types is None:
            self.var_types = ['continuous'] * n_vars
        elif isinstance(var_types, str):
            self.var_types = [var_types] * n_vars
        else:
            self.var_types = list(var_types[:n_vars])
            while len(self.var_types) < n_vars:
                self.var_types.append('continuous')

        # Track variable types
        self.has_integer_vars = any(vtype in ['integer', 'binary'] for vtype in self.var_types)
        self.has_continuous_vars = any(vtype == 'continuous' for vtype in self.var_types)

        # Create variables with individual domains
        self.model.x = pyo.Var(self.model.I)

        for i, var_type in enumerate(self.var_types, 1):
            if var_type == 'continuous':
                self.model.x[i].domain = pyo.Reals
            elif var_type == 'integer':
                self.model.x[i].domain = pyo.Integers
            elif var_type == 'binary':
                self.model.x[i].domain = pyo.Binary
            else:
                self.model.x[i].domain = pyo.Reals

        # Set bounds with safety for nonlinear functions
        if lb is not None:
            if isinstance(lb, (int, float)):
                lb = [lb] * n_vars
            for i, lower in enumerate(lb, 1):
                if lower is not None and i <= n_vars:
                    # Safe bounds for sqrt and other nonlinear functions
                    safe_lower = max(lower, 1e-6) if lower >= 0 else lower
                    self.model.x[i].setlb(safe_lower)

        if ub is not None:
            if isinstance(ub, (int, float)):
                ub = [ub] * n_vars
            for i, upper in enumerate(ub, 1):
                if upper is not None and i <= n_vars:
                    self.model.x[i].setub(upper)

        return self

    def set_objective(self, objective_func, sense='minimize'):
        """Set objective function with type detection"""
        if sense.lower() in ['minimize', 'min']:
            self.model.obj = pyo.Objective(expr=objective_func(self.model), sense=pyo.minimize)
        else:
            self.model.obj = pyo.Objective(expr=objective_func(self.model), sense=pyo.maximize)

        self._detect_problem_type()
        return self

    def _detect_problem_type(self):
        """Detect problem type based on objective and variables"""
        self.has_quadratic_terms = False
        self.has_nonlinear_terms = False

        try:
            obj_str = str(self.model.obj.expr).lower()

            # Check for quadratic terms
            import re
            if (re.search(r'x\[\d+\]\*\*2', obj_str) or
                    re.search(r'x\[\d+\]\s*\*\s*x\[\d+\]', obj_str)):
                self.has_quadratic_terms = True

            # Check for nonlinear terms (sqrt, exp, log, higher powers)
            nonlinear_keywords = ['exp', 'log', 'sin', 'cos', 'sqrt']
            higher_powers = [f'**{i}' for i in range(3, 10)] + ['**0.5', '**1.5']

            if (any(keyword in obj_str for keyword in nonlinear_keywords) or
                    any(power in obj_str for power in higher_powers)):
                self.has_nonlinear_terms = True

        except:
            pass

        # Determine problem type
        if self.has_integer_vars and self.has_continuous_vars:
            # Mixed integer problem
            if self.has_nonlinear_terms:
                self.problem_type = "MINLP"
            elif self.has_quadratic_terms:
                self.problem_type = "MIQP"
            else:
                self.problem_type = "MILP"
        elif self.has_integer_vars:
            # Pure integer problem
            if self.has_nonlinear_terms:
                self.problem_type = "INLP"
            elif self.has_quadratic_terms:
                self.problem_type = "IQP"
            else:
                self.problem_type = "ILP"
        else:
            # Pure continuous problem
            if self.has_nonlinear_terms:
                self.problem_type = "NLP"
            elif self.has_quadratic_terms:
                self.problem_type = "QP"
            else:
                self.problem_type = "LP"

    def add_constraint(self, constraint_func, sense='<=', name=None):
        """Add single constraint"""
        self.constraint_counter += 1
        if name is None:
            name = f"constraint_{self.constraint_counter}"

        if sense == '<=':
            expr = constraint_func(self.model) <= 0
        elif sense == '>=':
            expr = constraint_func(self.model) >= 0
        else:  # '='
            expr = constraint_func(self.model) == 0

        setattr(self.model, name, pyo.Constraint(expr=expr))
        return self

    def add_linear_constraints(self, A, b, sense='<='):
        """Add multiple linear constraints"""
        A = np.array(A)
        b = np.array(b)

        if A.ndim == 1:
            A = A.reshape(1, -1)

        self.constraint_counter += 1
        constraint_name = f'linear_constraints_{self.constraint_counter}'

        if sense == '<=':
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) <= b[i - 1]
        elif sense == '>=':
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) >= b[i - 1]
        else:  # '='
            def rule(model, i):
                return sum(A[i - 1, j - 1] * model.x[j] for j in model.I) == b[i - 1]

        setattr(self.model, constraint_name,
                pyo.Constraint(pyo.RangeSet(1, len(b)), rule=rule))

        return self

    def solve(self, solver=None, options=None, verbose=False):
        """Solve optimization problem"""
        if self.model is None:
            print("âŒ No model created!")
            return False

        # Auto-select solver
        if solver is None:
            if self.problem_type in ["LP", "QP", "NLP"]:
                solver = "ipopt" if self.problem_type == "NLP" else "gurobi"
            else:
                solver = "gurobi" if pyo.SolverFactory('gurobi').available() else "ipopt"

        if not pyo.SolverFactory(solver).available():
            print(f"âŒ Solver {solver} not available!")
            return False

        # Create solver
        self.solver = pyo.SolverFactory(solver)

        # Set solver options
        if solver == 'ipopt':
            clean_options = {
                'print_level': 0,  # Silent IPOPT
                'max_iter': 3000,
                'tol': 1e-6,
                'linear_solver': 'mumps'
            }
            if options:
                clean_options.update(options)

            for key, value in clean_options.items():
                self.solver.options[key] = value
        elif options:
            for key, value in options.items():
                self.solver.options[key] = value

        # Set safe initial point for nonlinear problems
        if self.has_nonlinear_terms:
            try:
                for i in self.model.I:
                    if self.model.x[i].value is None:
                        lb = self.model.x[i].lb if self.model.x[i].lb is not None else 0
                        ub = self.model.x[i].ub if self.model.x[i].ub is not None else 10
                        initial_val = max((lb + ub) / 2, 0.1)
                        self.model.x[i].set_value(initial_val)
            except:
                pass

        # Solve
        try:
            self.results = self.solver.solve(self.model, tee=verbose)

            if (self.results.solver.status == SolverStatus.ok and
                    self.results.solver.termination_condition in [TerminationCondition.optimal,
                                                                  TerminationCondition.locallyOptimal,
                                                                  TerminationCondition.feasible]):
                return True
            else:
                return False

        except:
            return False

    def get_solution(self):
        """Get solution information"""
        if not self.results:
            return None

        try:
            solution = {
                'objective_value': pyo.value(self.model.obj),
                'variables': {},
                'variable_types': {},
                'problem_type': self.problem_type,
                'solver_status': str(self.results.solver.status),
                'termination_condition': str(self.results.solver.termination_condition),
                'has_mixed_variables': self.has_integer_vars and self.has_continuous_vars
            }

            for i in self.model.I:
                var_name = self.var_names[i - 1]
                var_type = self.var_types[i - 1]
                value = pyo.value(self.model.x[i])
                solution['variables'][var_name] = value if value is not None else 0.0
                solution['variable_types'][var_name] = var_type

            return solution
        except:
            return None

    def print_solution(self):
        solution = self.get_solution()
        if not solution:
            print("âŒ No solution available")
            return

        print(f"\nğŸ“Š {solution['problem_type']} SOLUTION")
        print("=" * 50)
        print(f"Objective Value: {solution['objective_value']:.6f}")

        # Show variable types for mixed problems
        if solution['has_mixed_variables']:
            print("Variable Types:")
            continuous_vars = [name for name, vtype in solution['variable_types'].items()
                               if vtype == 'continuous']
            integer_vars = [name for name, vtype in solution['variable_types'].items()
                            if vtype == 'integer']
            binary_vars = [name for name, vtype in solution['variable_types'].items()
                           if vtype == 'binary']

            if continuous_vars:
                print(f"  Continuous: {', '.join(continuous_vars)}")
            if integer_vars:
                print(f"  Integer: {', '.join(integer_vars)}")
            if binary_vars:
                print(f"  Binary: {', '.join(binary_vars)}")

        print("Variable Values:")
        for name, value in solution['variables'].items():
            var_type = solution['variable_types'][name]
            if var_type in ['integer', 'binary'] and abs(value - round(value)) < 1e-6:
                print(f"  {name} = {int(round(value))} ({var_type})")
            else:
                print(f"  {name} = {value:.6f} ({var_type})")

    def plot_solution_2d(self, x_range=None, y_range=None, title=None, figsize=(10, 7)):
        """Plot 2D solution with ALL ENGLISH LABELS"""
        solution = self.get_solution()
        if not solution or len(solution['variables']) != 2:
            print(
                f"âš ï¸ Cannot plot: Problem has {len(solution['variables']) if solution else 0} variables (need exactly 2 for 2D plot)")
            return

        if x_range is None:
            x_range = (0, 10)
        if y_range is None:
            y_range = (0, 10)
        if title is None:
            title = f"{self.name}"

        # Get solution point and variable types
        vars_list = list(solution['variables'].items())
        x_opt, y_opt = vars_list[0][1], vars_list[1][1]
        x_name, y_name = vars_list[0][0], vars_list[1][0]
        x_type = solution['variable_types'][x_name]
        y_type = solution['variable_types'][y_name]

        # Create plot with ALL ENGLISH LABELS
        fig, ax = plt.subplots(figsize=figsize)

        # Plot optimal point with markers based on variable types
        if x_type in ['integer', 'binary'] or y_type in ['integer', 'binary']:
            ax.plot(x_opt, y_opt, 'rs', markersize=14, zorder=5,
                    label=f'Optimal Solution\n({x_opt:.3f}, {y_opt:.3f})')
        else:
            ax.plot(x_opt, y_opt, 'ro', markersize=14, zorder=5,
                    label=f'Optimal Solution\n({x_opt:.3f}, {y_opt:.3f})')

        # Annotation with ENGLISH TEXT and variable types
        annotation_text = (f'Optimal Point\n'
                           f'{x_name}: {x_opt:.3f} ({x_type})\n'
                           f'{y_name}: {y_opt:.3f} ({y_type})\n'
                           f'Objective Value: {solution["objective_value"]:.3f}')

        ax.annotate(annotation_text,
                    xy=(x_opt, y_opt),
                    xytext=(x_opt + (x_range[1] - x_range[0]) * 0.15,
                            y_opt + (y_range[1] - y_range[0]) * 0.15),
                    arrowprops=dict(arrowstyle='->', color='red', lw=2),
                    bbox=dict(boxstyle="round,pad=0.5", facecolor="yellow", alpha=0.8),
                    fontsize=12, ha='left')

        # Set ALL ENGLISH AXIS LABELS
        ax.set_xlim(x_range)
        ax.set_ylim(y_range)
        ax.set_xlabel(f'{x_name} ({x_type})', fontsize=14, fontweight='bold')
        ax.set_ylabel(f'{y_name} ({y_type})', fontsize=14, fontweight='bold')
        ax.set_title(f'{title} ({solution["problem_type"]} Problem)',
                     fontsize=16, fontweight='bold')

        ax.grid(True, alpha=0.3)
        ax.legend(fontsize=12, loc='best')

        # Add variable information box in ENGLISH
        if solution['has_mixed_variables']:
            info_text = "Mixed Variable Types:\n"
            for name, vtype in solution['variable_types'].items():
                info_text += f"{name}: {vtype}\n"

            ax.text(0.02, 0.98, info_text.strip(), transform=ax.transAxes,
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.7),
                    fontsize=10, verticalalignment='top')

        # ENGLISH TIMESTAMP
        timestamp_text = f"Generated: 2025-06-20 10:58:07 UTC | User: giraffishh"
        fig.text(0.99, 0.01, timestamp_text, ha='right', va='bottom',
                 fontsize=9, alpha=0.6)

        plt.tight_layout()
        plt.show()
        print(f"âœ… Plot created for {solution['problem_type']} problem with ALL ENGLISH LABELS")
```
{% endfold %}

**`solve.py`:**

```python
from unified_regressor import OptimizationSolver

def main():
    # èˆ±å‚æ•°
    W = [10, 16, 8]  # é‡é‡é™åˆ¶ (t)
    V = [6800, 8700, 5300]  # ä½“ç§¯é™åˆ¶ (m^3)

    # è´§ç‰©å‚æ•°
    P = [3100, 3800, 3500, 2850]  # åˆ©æ¶¦ (å…ƒ/t)
    Q = [480, 650, 580, 390]  # ç©ºé—´ (m^3/t)
    A = [18, 15, 23, 12]  # æ¯ç§è´§ç‰©æœ€å¤§å¯ç”¨æ€»é‡é‡ (t)

    solver = OptimizationSolver("Cargo_Allocation")
    var_names = [f"x{i + 1}{j + 1}" for i in range(4) for j in range(3)]
    solver.create_model(12, var_names=var_names, var_types='continuous', lb=0)

    # ç›®æ ‡å‡½æ•°
    def obj(model):
        return sum(P[i] * model.x[3 * i + j + 1] for i in range(4) for j in range(3))

    solver.set_objective(obj, 'maximize')

    # å„èˆ±é‡é‡çº¦æŸ
    for j in range(3):
        solver.add_constraint(lambda model, j=j: sum(model.x[3 * i + j + 1] for i in range(4)) - W[j], '<=')

    # å„èˆ±ä½“ç§¯çº¦æŸ
    for j in range(3):
        solver.add_constraint(lambda model, j=j: sum(Q[i] * model.x[3 * i + j + 1] for i in range(4)) - V[j], '<=')

    # æ¯ç§è´§ç‰©æ€»é‡çº¦æŸ
    for i in range(4):
        solver.add_constraint(lambda model, i=i: sum(model.x[3 * i + j + 1] for j in range(3)) - A[i], '<=')

    # å¹³è¡¡çº¦æŸ
    solver.add_constraint(
        lambda model: 16 * sum(model.x[3 * i + 1] for i in range(4)) - 10 * sum(model.x[3 * i + 2] for i in range(4)),
        '=')
    solver.add_constraint(
        lambda model: 8 * sum(model.x[3 * i + 2] for i in range(4)) - 16 * sum(model.x[3 * i + 3] for i in range(4)),
        '=')

    solver.solve()
    solver.print_solution()

    # Print total loaded for each good
    solution = solver.get_solution()
    if solution:
        print("\nTotal loaded for each good:")
        for i in range(4):
            total = sum(solution['variables'][f"x{i + 1}{j + 1}"] for j in range(3))
            print(f"  Good {i + 1} total: {total:.6f} t")

if __name__ == "__main__":
    main()
```