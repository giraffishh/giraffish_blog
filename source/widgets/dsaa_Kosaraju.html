<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kosaraju 算法可视化演示 (Pro)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');

        :root {
            --primary: #4f46e5;
            --primary-light: #818cf8;
            --bg-canvas: #f8fafc;
            --bg-panel: rgba(255, 255, 255, 0.95);
            --border-color: #e2e8f0;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg-canvas);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- 头部 --- */
        header {
            background: white;
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            height: 50px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-sm);
            z-index: 50;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            font-size: 1.1rem;
            color: #0f172a;
        }
        
        .badge-info {
            background: #eef2ff;
            color: var(--primary);
            padding: 4px 12px;
            border-radius: 99px;
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid #c7d2fe;
        }

        /* --- 主布局 --- */
        main {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
            flex-direction: column; /* 垂直 50:50 */
        }

        /* 上半部分：图表区 */
        .panel-top {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            background-color: #f1f5f9;
            background-image: 
                radial-gradient(#cbd5e1 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            overflow: hidden;
            border-bottom: 1px solid var(--border-color);
            min-height: 0;
        }

        /* 下半部分：数据区 */
        .panel-bottom {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.03);
            z-index: 40;
            min-height: 0;
        }

        /* --- Canvas --- */
        #canvas-wrapper {
            flex: 1;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }
        canvas {
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            background: white;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; 
        }

        /* --- 悬浮图例 --- */
        .legend-card {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: var(--shadow-md);
            font-size: 0.8rem;
            z-index: 10;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            color: var(--text-sub);
            font-weight: 500;
        }
        .legend-item:last-child { margin-bottom: 0; }
        .dot { width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 0 1px #cbd5e1; }
        .legend-arrow { width: 20px; height: 2px; position: relative; background: #94a3b8; }
        .legend-arrow::after { content:''; position:absolute; right:0; top:-3px; border: 4px solid transparent; border-left-color:#94a3b8; }

        /* --- 悬浮控制栏 (右侧垂直) --- */
        .controls-island {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 8px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 20;
        }
        
        .btn {
            border: none;
            background: transparent;
            padding: 8px;
            border-radius: 10px;
            font-family: 'Plus Jakarta Sans', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--text-sub);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 48px;
        }
        .btn span { font-size: 0.7rem; }
        .btn:hover:not(:disabled) { background: #f1f5f9; color: var(--text-main); transform: translateY(-1px); }
        .btn:active:not(:disabled) { transform: translateY(0); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .btn-primary {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.3);
        }
        .btn-primary:hover:not(:disabled) { background: #4338ca; color: white; box-shadow: 0 6px 8px -1px rgba(79, 70, 229, 0.4); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-danger:hover { background: #dc2626; color: white; }

        /* --- 下方数据面板 --- */
        .panel-header {
            padding: 12px 24px;
            background: linear-gradient(135deg, #fff, #f8fafc);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }
        .pulse-dot { width: 8px; height: 8px; background: var(--primary); border-radius: 50%; box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15); }
        .status-text {
            font-size: 0.9rem;
            line-height: 1.4;
            color: var(--text-main);
            font-weight: 500;
        }

        /* 左右分块容器 */
        .split-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            flex-direction: row;
        }

        .section-left {
            flex: 1;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .section-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .scroll-content {
            flex: 1;
            overflow-y: auto;
            background: #fff;
        }

        .section-title {
            padding: 10px 24px;
            background: #f8fafc;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-sub);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* 数据表 */
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table th {
            text-align: left; padding: 8px 16px; font-size: 0.75rem; color: var(--text-sub);
            background: white; border-bottom: 1px solid var(--border-color);
            position: sticky; top: 0; z-index: 5;
        }
        .data-table td {
            padding: 8px 16px; font-size: 0.85rem; border-bottom: 1px solid #f1f5f9;
        }
        .data-table tr:last-child td { border-bottom: none; }

        /* 栈列表 (Stack List) */
        .stack-list { 
            padding: 12px 16px; 
            display: flex; 
            flex-direction: column-reverse; /* Stack builds upwards */
            gap: 8px; 
            align-items: center;
        }
        .stack-item {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background: white;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'JetBrains Mono';
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            animation: slideIn 0.3s forwards;
        }
        .stack-item.popped {
            opacity: 0.5;
            background: #f1f5f9;
            text-decoration: line-through;
        }
        /* 弹出时的动画状态 */
        .stack-item.active-pop {
            border-color: var(--danger);
            background: #fef2f2;
            color: #b91c1c;
            transform: translateX(10px);
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.1);
        }
        
        .finish-badge-stack {
            display: inline-block;
            background: #eef2ff;
            color: #4f46e5;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            font-weight: bold;
        }

        @keyframes slideIn { from { opacity:0; transform: translateY(10px); } to { opacity:1; transform: translateY(0); } }

        /* 动画 */
        .anim-update { animation: highlight-pulse 1s; }
        @keyframes highlight-pulse { 0% { background-color: #fef3c7; } 100% { background-color: transparent; } }

        /* 滚动条 */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        @media (max-width: 900px) {
            .legend-card {
                transform: scale(0.85);
                transform-origin: top left;
            }
            .controls-island {
                transform: translateY(-50%) scale(0.85);
                transform-origin: center right;
            }
        }

        @media (max-width: 600px) {
            .split-container { flex-direction: column; }
            .section-left { border-right: none; border-bottom: 1px solid var(--border-color); height: 50%; }
            .section-right { height: 50%; }

            /* 小屏幕下进一步缩小 */
            .legend-card {
                transform: scale(0.5);
                max-width: 160px;
            }
            .controls-island {
                transform: translateY(-50%) scale(0.5);
            }
        }
    </style>
</head>
<body>

    <header>
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--primary);">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
            Kosaraju 动图详解
        </div>
        <div class="badge-info">SCC 强连通分量</div>
    </header>

    <main>
        <!-- 上半部分：图表 -->
        <div class="panel-top">
            <div id="canvas-wrapper">
                <div class="legend-card">
                    <div class="legend-item"><span class="dot" style="background:#f1f5f9; border-color:#94a3b8;"></span>未访问</div>
                    <div class="legend-item"><span class="dot" style="background:#fef08a; border-color:#ca8a04;"></span>当前节点</div>
                    <div class="legend-item"><span class="dot" style="background:#86efac; border-color:#16a34a;"></span>SCC 1</div>
                    <div class="legend-item"><span class="dot" style="background:#93c5fd; border-color:#2563eb;"></span>SCC 2</div>
                    <div class="legend-item"><span class="dot" style="background:#fca5a5; border-color:#ea580c;"></span>SCC 3</div>
                    <div class="legend-item"><span class="dot" style="background:#f5d0fe; border-color:#a855f7; display:flex; justify-content:center; align-items:center; font-size:8px; color:#6b21a8; font-weight:bold;">#1</span>完成次序</div>
                </div>

                <canvas id="graphCanvas" width="800" height="600"></canvas>

                <div class="controls-island">
                    <button id="btnReset" class="btn" title="重置">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                        <span>重置</span>
                    </button>
                    <button id="btnPrev" class="btn" title="上一步">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        <span>后退</span>
                    </button>
                    <button id="btnPlay" class="btn btn-primary" title="自动播放">
                        <svg id="iconPlay" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        <span>播放</span>
                    </button>
                    <button id="btnNext" class="btn" title="下一步">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        <span>前进</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- 下半部分：数据 -->
        <div class="panel-bottom">
            <div class="panel-header">
                <div class="status-badge">
                    <div class="pulse-dot"></div>
                    <span>算法阶段: <span id="phaseName">Ready</span></span>
                </div>
                <div id="statusText" class="status-text">
                    准备就绪。Kosaraju 算法将分两遍 DFS 找出强连通分量。
                </div>
            </div>

            <div class="split-container">
                <!-- 左下：节点状态表 -->
                <div class="section-left">
                    <div class="section-title">节点表 (Node Status)</div>
                    <div class="scroll-content">
                        <table class="data-table">
                            <thead>
                                <tr><th>Node</th><th>Finish #</th><th>SCC ID</th></tr>
                            </thead>
                            <tbody id="distTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- 右下：栈 -->
                <div class="section-right">
                    <div class="section-title">栈 (按完成次序从下到上)</div>
                    <div class="scroll-content" style="background:#f8fafc;">
                        <div id="stackContainer" class="stack-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- 1. Graph Data (Directed) ---
        const nodes = [
            { id: 'A', x: 150, y: 200 },
            { id: 'B', x: 250, y: 100 },
            { id: 'C', x: 250, y: 300 },
            { id: 'D', x: 450, y: 200 },
            { id: 'E', x: 550, y: 100 },
            { id: 'F', x: 550, y: 300 },
            { id: 'G', x: 700, y: 200 }
        ];

        // Edges: A cycle (A-B-C), D-E-F cycle, connecting edges
        const initialEdges = [
            { from: 'A', to: 'B' }, { from: 'B', to: 'C' }, { from: 'C', to: 'A' }, // SCC 1
            { from: 'B', to: 'D' }, // Connection
            { from: 'D', to: 'E' }, { from: 'E', to: 'F' }, { from: 'F', to: 'D' }, // SCC 2
            { from: 'E', to: 'G' }  // SCC 3 (Single Node)
        ];

        // SCC Colors
        const sccColors = ['#86efac', '#93c5fd', '#fca5a5', '#fdba74', '#d8b4fe'];

        // --- 2. Canvas Setup ---
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        let canvasDims = { width: 800, height: 600 };

        function setupCanvas() {
            const container = document.getElementById('canvas-wrapper');
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            const w = rect.width - 40; 
            const h = rect.height - 40;
            if (w <= 0 || h <= 0) return { width: 800, height: 600 };
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${w}px`; canvas.style.height = `${h}px`;
            return { width: w, height: h };
        }

        function getScaleFactors(width, height) {
            const scaleX = width / 800; const scaleY = height / 600;
            const scale = Math.min(scaleX, scaleY);
            const offsetX = (width - 800 * scale) / 2;
            const offsetY = (height - 600 * scale) / 2;
            return { scale, offsetX, offsetY };
        }

        // --- 3. Kosaraju Algorithm Logic ---
        function generateSteps() {
            const steps = [];
            const visited = new Set();
            const stack = [];
            const finishOrder = {}; // nodeId -> number
            let finishCounter = 0;
            const sccMap = {}; // nodeId -> sccId
            let edges = [...initialEdges]; 
            let phase = '第一次 DFS';

            const getAdj = (edgeList) => {
                const adj = {};
                nodes.forEach(n => adj[n.id] = []);
                edgeList.forEach(e => adj[e.from].push(e.to));
                return adj;
            };

            // Initial State
            steps.push({
                type: 'INIT', msg: '初始化: 准备进行第一次 DFS。图中将标记节点的[完成次序]。',
                visited: new Set(visited), stack: [...stack], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                currNode: null, edges: edges, phase: phase
            });

            // --- PASS 1: DFS to fill Stack ---
            const adj = getAdj(edges);
            
            const dfs1 = (u) => {
                visited.add(u);
                steps.push({
                    type: 'VISIT', msg: `第一次 DFS: 访问节点 ${u}。`,
                    visited: new Set(visited), stack: [...stack], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                    currNode: u, edges: edges, phase: phase
                });

                for (let v of adj[u]) {
                    if (!visited.has(v)) {
                        dfs1(v);
                        steps.push({
                            type: 'BACKTRACK', msg: `第一次 DFS: 回溯到节点 ${u}。`,
                            visited: new Set(visited), stack: [...stack], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                            currNode: u, edges: edges, phase: phase
                        });
                    }
                }
                
                // Post-order processing
                finishCounter++;
                finishOrder[u] = finishCounter;
                stack.push(u);
                
                steps.push({
                    type: 'PUSH', msg: `第一次 DFS: 节点 ${u} 处理完毕 (#${finishCounter})，推入栈中。`,
                    visited: new Set(visited), stack: [...stack], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                    currNode: u, edges: edges, phase: phase
                });
            };

            nodes.forEach(n => {
                if (!visited.has(n.id)) {
                    dfs1(n.id);
                }
            });

            // --- TRANSPOSE GRAPH ---
            phase = '图转置';
            const transposedEdges = edges.map(e => ({ from: e.to, to: e.from }));
            
            steps.push({
                type: 'TRANSPOSE', msg: '图转置: 反转所有边的方向。保留完成次序，清空访问记录。',
                visited: new Set(), stack: [...stack], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                currNode: null, edges: transposedEdges, phase: phase
            });

            // --- PASS 2: DFS on Transpose ---
            phase = '第二次 DFS (找 SCC)';
            const adjT = getAdj(transposedEdges);
            const visited2 = new Set();
            let sccCounter = 0;
            
            let workingStack = [...stack]; 

            const dfs2 = (u, sccId) => {
                visited2.add(u);
                sccMap[u] = sccId;
                
                steps.push({
                    type: 'SCC_VISIT', msg: `第二次 DFS: 访问 ${u}，归入 SCC #${sccId}。`,
                    visited: new Set(visited2), stack: [...workingStack], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                    currNode: u, edges: transposedEdges, phase: phase
                });

                for (let v of adjT[u]) {
                    if (!visited2.has(v)) {
                        dfs2(v, sccId);
                    }
                }
            };

            while (workingStack.length > 0) {
                const u = workingStack.pop();
                
                // Create a temporary stack for visual purposes that INCLUDES the popped item
                const visualStack = [...workingStack, u];

                // Optimized Step Generation: Merge POP and CHECK
                if (!visited2.has(u)) {
                    sccCounter++;
                    
                    // 合并步骤：弹出 + 确认新 SCC
                    steps.push({
                        type: 'POP_NEW_SCC', 
                        msg: `第二次 DFS: 弹出栈顶节点 ${u} (完成次序 #${finishOrder[u]})。该节点未访问，开启新强连通分量 SCC #${sccCounter}。`,
                        visited: new Set(visited2), 
                        stack: visualStack, // Show stack with u still inside (but marked)
                        sccMap: {...sccMap}, finishOrder: {...finishOrder},
                        currNode: u, edges: transposedEdges, phase: phase, 
                        popTarget: u // Signal to UI to highlight this item
                    });
                    
                    dfs2(u, sccCounter);
                } else {
                    // It is already visited, just skip
                    steps.push({
                        type: 'SKIP', msg: `第二次 DFS: 弹出栈顶节点 ${u} (完成次序 #${finishOrder[u]})。该节点已归属 SCC，跳过。`,
                        visited: new Set(visited2), 
                        stack: visualStack, // Show stack with u still inside (but marked)
                        sccMap: {...sccMap}, finishOrder: {...finishOrder},
                        currNode: null, edges: transposedEdges, phase: phase, 
                        popTarget: u // Signal to UI to highlight this item
                    });
                }
            }

            steps.push({
                type: 'DONE', msg: `算法完成！共找到 ${sccCounter} 个强连通分量。`,
                visited: new Set(visited2), stack: [], sccMap: {...sccMap}, finishOrder: {...finishOrder},
                currNode: null, edges: transposedEdges, phase: 'Done'
            });

            return steps;
        }

        // --- 4. Drawing ---
        const steps = generateSteps();
        let currentStepIndex = 0;
        let animationInterval = null;

        function drawArrow(ctx, fromX, fromY, toX, toY, r, color, lineWidth) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const startX = fromX + r * Math.cos(angle);
            const startY = fromY + r * Math.sin(angle);
            const endX = toX - r * Math.cos(angle);
            const endY = toY - r * Math.sin(angle);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();

            const headLen = 10 * (lineWidth / 2); 
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(endX, endY);
            ctx.fillStyle = color;
            ctx.fill();
        }

        function drawGraph(state) {
            const { width, height } = canvasDims;
            const { scale, offsetX, offsetY } = getScaleFactors(width, height);
            ctx.clearRect(0, 0, width, height);

            const tx = (val) => val * scale + offsetX;
            const ty = (val) => val * scale + offsetY;

            // Draw Edges
            state.edges.forEach(edge => {
                const n1 = nodes.find(n => n.id === edge.from);
                const n2 = nodes.find(n => n.id === edge.to);
                const x1 = tx(n1.x), y1 = ty(n1.y);
                const x2 = tx(n2.x), y2 = ty(n2.y);
                const r = 36 * scale;

                let color = '#cbd5e1';
                let width = 2 * scale;

                if (state.sccMap[edge.from] && state.sccMap[edge.to] && 
                    state.sccMap[edge.from] === state.sccMap[edge.to]) {
                    color = sccColors[(state.sccMap[edge.from] - 1) % sccColors.length];
                    width = 4 * scale;
                }

                // Highlight edges in Red during Transpose phase
                if (state.phase === '图转置') {
                    color = '#ef4444'; // Red-500
                    width = 3 * scale;
                }

                drawArrow(ctx, x1, y1, x2, y2, r, color, width);
            });

            // Draw Nodes
            nodes.forEach(node => {
                const x = tx(node.x), y = ty(node.y);
                const r = 36 * scale;
                
                let bg = 'white'; let border = '#cbd5e1'; let text = '#475569';
                let shadowColor = 'rgba(0,0,0,0.05)'; let shadowSize = 10;

                const sccId = state.sccMap[node.id];
                if (sccId) {
                    const color = sccColors[(sccId - 1) % sccColors.length];
                    bg = '#ffffff'; border = color; shadowColor = color; text = '#1e293b';
                }

                if (state.currNode === node.id) { 
                    bg = '#fffbeb'; 
                    if (!sccId) border = '#f59e0b'; 
                    shadowSize = 25;
                } else if (state.visited.has(node.id) && !sccId && state.phase.includes('第一次')) {
                    bg = '#f1f5f9'; border = '#94a3b8';
                }

                ctx.shadowColor = shadowColor; ctx.shadowBlur = shadowSize; ctx.shadowOffsetY = 4;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = bg; ctx.fill();
                
                ctx.shadowColor = 'transparent';
                ctx.lineWidth = (state.currNode === node.id || sccId) ? 4 : 2; 
                ctx.strokeStyle = border; ctx.stroke();

                ctx.fillStyle = text; 
                ctx.font = `bold ${26 * scale}px "Plus Jakarta Sans"`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(node.id, x, y);

                // Draw Finish Order Badge (Top Right)
                const fOrder = state.finishOrder[node.id];
                if (fOrder) {
                    const badgeR = 12 * scale;
                    const badgeX = x + r * 0.7;
                    const badgeY = y - r * 0.7;
                    
                    ctx.beginPath();
                    ctx.arc(badgeX, badgeY, badgeR, 0, Math.PI * 2);
                    ctx.fillStyle = '#f5d0fe'; // Light purple
                    ctx.fill();
                    ctx.strokeStyle = '#c084fc';
                    ctx.lineWidth = 1 * scale;
                    ctx.stroke();

                    ctx.fillStyle = '#6b21a8'; // Dark purple text
                    ctx.font = `bold ${12 * scale}px "JetBrains Mono"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`#${fOrder}`, badgeX, badgeY);
                }

                // SCC Label (Bottom)
                if (sccId) {
                    const badgeY = y + r + 20 * scale;
                    const label = `SCC ${sccId}`;
                    ctx.font = `600 ${14 * scale}px "JetBrains Mono"`;
                    const metrics = ctx.measureText(label);
                    const bw = metrics.width + 16 * scale;
                    const bh = 24 * scale;
                    
                    const color = sccColors[(sccId - 1) % sccColors.length];
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    if (ctx.roundRect) ctx.roundRect(x - bw/2, badgeY - bh/2, bw, bh, bh/2);
                    else ctx.rect(x - bw/2, badgeY - bh/2, bw, bh);
                    ctx.fill();
                    
                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(label, x, badgeY + 1 * scale);
                }
            });
        }

        function updateUI(state) {
            document.getElementById('statusText').innerText = state.msg;
            document.getElementById('phaseName').innerText = state.phase;

            const tbody = document.getElementById('distTableBody');
            tbody.innerHTML = '';
            nodes.forEach(node => {
                const tr = document.createElement('tr');
                const isVisited = state.visited.has(node.id);
                const scc = state.sccMap[node.id] || '-';
                const fOrder = state.finishOrder[node.id] ? `#${state.finishOrder[node.id]}` : '-';
                const isCurr = state.currNode === node.id;
                
                if (isCurr) tr.className = 'anim-update';
                
                let visitedIcon = isVisited ? '<span style="color:#10b981">✓</span>' : '<span style="color:#cbd5e1">○</span>';

                tr.innerHTML = `
                    <td style="font-weight:600; color:#334155;">${node.id}</td>
                    <td style="font-family:'JetBrains Mono';">${fOrder}</td>
                    <td style="font-family:'JetBrains Mono'; font-weight:bold; color:${scc!=='='?'#4f46e5':'#64748b'}">${scc}</td>
                `;
                tbody.appendChild(tr);
            });

            // --- Stack Update (Prevent unnecessary re-renders) ---
            const stackContainer = document.getElementById('stackContainer');
            // Include popTarget in signature to force update when highlighting changes
            const currentStackSig = state.stack.join(',') + '|' + (state.popTarget || '');
            
            if (stackContainer.dataset.sig !== currentStackSig) {
                stackContainer.innerHTML = '';
                
                state.stack.forEach((item, idx) => {
                    const fOrder = state.finishOrder[item];
                    const el = document.createElement('div');
                    el.className = 'stack-item';
                    
                    // Add highlighting class
                    if (state.popTarget === item) {
                        el.classList.add('active-pop');
                    }
                    
                    el.innerHTML = `
                        <div><span class="finish-badge-stack">#${fOrder}</span> Node ${item}</div>
                    `;
                    stackContainer.appendChild(el);
                });
                stackContainer.dataset.sig = currentStackSig;
            }
            
            document.getElementById('btnPrev').disabled = currentStepIndex === 0;
            document.getElementById('btnNext').disabled = currentStepIndex === steps.length - 1;
        }

        function render() {
            const state = steps[currentStepIndex];
            requestAnimationFrame(() => {
                drawGraph(state);
                updateUI(state);
            });
        }

        const btnNext = document.getElementById('btnNext');
        const btnPrev = document.getElementById('btnPrev');
        const btnPlay = document.getElementById('btnPlay');
        const btnReset = document.getElementById('btnReset');

        function nextStep() { if (currentStepIndex < steps.length - 1) { currentStepIndex++; render(); } else stopPlay(); }
        function prevStep() { if (currentStepIndex > 0) { currentStepIndex--; render(); } }
        function reset() { stopPlay(); currentStepIndex = 0; render(); }
        
        function togglePlay() {
            if (animationInterval) { stopPlay(); } 
            else {
                if (currentStepIndex === steps.length - 1) currentStepIndex = 0;
                btnPlay.classList.add('btn-danger');
                btnPlay.classList.remove('btn-primary');
                const svg = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
                btnPlay.innerHTML = `${svg}<span>暂停</span>`;
                nextStep();
                animationInterval = setInterval(nextStep, 1500);
            }
        }
        function stopPlay() {
            clearInterval(animationInterval); animationInterval = null;
            btnPlay.classList.remove('btn-danger');
            btnPlay.classList.add('btn-primary');
            const svg = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
            btnPlay.innerHTML = `${svg}<span>播放</span>`;
        }

        btnNext.addEventListener('click', () => { stopPlay(); nextStep(); });
        btnPrev.addEventListener('click', () => { stopPlay(); prevStep(); });
        btnReset.addEventListener('click', reset);
        btnPlay.addEventListener('click', togglePlay);

        window.addEventListener('load', () => { canvasDims = setupCanvas(); render(); });
        window.addEventListener('resize', () => { canvasDims = setupCanvas(); render(); });

    </script>
</body>
</html>