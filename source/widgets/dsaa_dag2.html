<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFS 拓扑排序 (Kahn算法) - Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');

        :root {
            --primary: #4f46e5;
            --bg-canvas: #f8fafc;
            --border-color: #e2e8f0;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            
            /* 状态色 */
            --color-white: #ffffff;
            --color-waiting: #e2e8f0; /* Gray-200 (In-degree > 0) */
            --color-ready: #86efac;   /* Green-300 (In-degree = 0, Enqueued) */
            --color-process: #fca5a5; /* Red-300 (Processing) */
            --color-done: #93c5fd;    /* Blue-300 (Sorted) */
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg-canvas);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            background: white;
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            height: 50px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
        }
        .brand {
            display: flex; align-items: center; gap: 10px;
            font-weight: 700; font-size: 1.1rem; color: #0f172a;
        }
        .badge-info {
            background: #eef2ff; color: var(--primary);
            padding: 4px 12px; border-radius: 99px;
            font-size: 0.75rem; font-weight: 600;
            font-family: 'JetBrains Mono'; border: 1px solid #c7d2fe;
        }

        /* --- Main Layout --- */
        main {
            flex: 1; display: flex; flex-direction: column;
            overflow: hidden; position: relative;
        }

        .panel-top {
            flex: 1;
            position: relative;
            background-color: #f8fafc;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 24px 24px;
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }

        .panel-bottom {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.03);
            z-index: 40;
        }

        /* --- Canvas --- */
        #canvas-wrapper {
            flex: 1; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box;
        }
        canvas {
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            background: white;
            max-width: 100%; max-height: 100%;
            object-fit: contain;
        }

        /* --- Controls --- */
        .controls-island {
            position: absolute; top: 50%; right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 8px; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: var(--shadow-lg);
            display: flex; flex-direction: column; gap: 12px;
            z-index: 20;
        }
        .btn {
            border: none; background: transparent;
            padding: 8px; border-radius: 10px;
            font-family: 'Plus Jakarta Sans'; font-weight: 600; font-size: 0.85rem;
            cursor: pointer; color: var(--text-sub);
            display: flex; flex-direction: column; align-items: center; gap: 4px;
            min-width: 48px; transition: all 0.2s;
        }
        .btn:hover:not(:disabled) { background: #f1f5f9; color: var(--text-main); transform: translateY(-1px); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn span { font-size: 0.7rem; }
        .btn-primary { background: var(--primary); color: white; box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.3); }
        .btn-primary:hover:not(:disabled) { background: #4338ca; color: white; }
        .btn-danger { background: #ef4444; color: white; }
        
        /* --- Legend --- */
        .legend-card {
            position: absolute; top: 24px; left: 24px;
            background: rgba(255,255,255,0.9); backdrop-filter: blur(8px);
            padding: 12px 16px; border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: var(--shadow-lg); font-size: 0.8rem; z-index: 20;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-weight: 500; color: var(--text-sub); }
        .legend-item:last-child { margin-bottom: 0; }
        .dot { width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 0 1px #cbd5e1; }

        /* --- Bottom Panel --- */
        .panel-header {
            padding: 12px 24px;
            background: linear-gradient(135deg, #fff, #f8fafc);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .status-badge {
            display: inline-flex; align-items: center; gap: 6px;
            font-size: 0.75rem; font-weight: 700; color: var(--primary);
            text-transform: uppercase; margin-bottom: 4px;
        }
        .pulse-dot { width: 8px; height: 8px; background: var(--primary); border-radius: 50%; box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15); }
        .status-text { font-size: 0.9rem; font-weight: 500; line-height: 1.4; }

        .split-container { flex: 1; display: flex; overflow: hidden; }
        .section-left, .section-right { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .section-left { border-right: 1px solid var(--border-color); }
        
        .section-title {
            padding: 10px 24px; background: #f8fafc;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.8rem; font-weight: 700; color: var(--text-sub);
            text-transform: uppercase; letter-spacing: 0.05em;
            display: flex; justify-content: space-between;
        }
        .scroll-content { flex: 1; overflow-y: auto; background: white; }

        /* Table */
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table th {
            text-align: left; padding: 8px 16px; font-size: 0.75rem; color: var(--text-sub);
            background: white; border-bottom: 1px solid var(--border-color); position: sticky; top: 0;
        }
        .data-table td { padding: 8px 16px; font-size: 0.85rem; border-bottom: 1px solid #f1f5f9; }
        .color-tag {
            display: inline-block; padding: 2px 8px; border-radius: 4px; 
            font-size: 0.7rem; font-weight: 700; text-transform: uppercase;
        }

        /* Queue Visual (Horizontal) */
        .queue-container { padding: 16px; overflow-x: auto; white-space: nowrap; display: flex; gap: 8px; align-items: center; min-height: 60px;}
        .queue-item {
            display: inline-flex; flex-direction: column; align-items: center; justify-content: center;
            width: 40px; height: 40px; border-radius: 8px;
            background: #f0fdf4; border: 1px solid #86efac;
            color: #15803d; font-weight: 700; font-family: 'JetBrains Mono';
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .queue-label { font-size: 0.7rem; color: #cbd5e1; margin-right: 8px; font-weight: 700;}

        /* Result List */
        .result-list { padding: 12px 24px; display: flex; flex-wrap: wrap; gap: 8px; }
        .result-item {
            padding: 4px 10px; background: #eff6ff; border: 1px solid #bfdbfe;
            border-radius: 6px; color: #1e40af; font-family: 'JetBrains Mono'; font-size: 0.85rem; font-weight: 600;
            display: flex; align-items: center; gap: 6px;
            animation: fadeIn 0.5s ease-out;
        }
        .result-arrow { color: #94a3b8; font-size: 0.8rem; }

        @keyframes popIn { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        
        .anim-row-update { background-color: #fef9c3; transition: background-color 0.5s; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
    </style>
</head>
<body>

    <header>
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--primary);">
                <polyline points="16 18 22 12 16 6"></polyline>
                <polyline points="8 6 2 12 8 18"></polyline>
            </svg>
            BFS 拓扑排序
        </div>
        <div class="badge-info">Kahn 算法</div>
    </header>

    <main>
        <div class="panel-top">
            <div class="legend-card">
                <div class="legend-item"><span class="dot" style="background:var(--color-waiting);"></span>等待中 (In > 0)</div>
                <div class="legend-item"><span class="dot" style="background:var(--color-ready); border-color:#22c55e;"></span>就绪/入队 (In = 0)</div>
                <div class="legend-item"><span class="dot" style="background:var(--color-process); border-color:#ef4444;"></span>处理中 (Dequeue)</div>
                <div class="legend-item"><span class="dot" style="background:var(--color-done); border-color:#3b82f6;"></span>已排序 (Sorted)</div>
            </div>

            <div id="canvas-wrapper">
                <canvas id="graphCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls-island">
                <button id="btnReset" class="btn">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
                    <span>重置</span>
                </button>
                <button id="btnPrev" class="btn">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                    <span>后退</span>
                </button>
                <button id="btnPlay" class="btn btn-primary">
                    <svg id="iconPlay" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    <span>播放</span>
                </button>
                <button id="btnNext" class="btn">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                    <span>前进</span>
                </button>
            </div>
        </div>

        <div class="panel-bottom">
            <div class="panel-header">
                <div class="status-badge">
                    <div class="pulse-dot"></div>
                    <span>当前操作</span>
                </div>
                <div id="statusText" class="status-text">
                    准备就绪。计算所有节点的初始入度 (In-Degree)。
                </div>
            </div>

            <div class="split-container">
                <!-- Left: In-Degree Table -->
                <div class="section-left">
                    <div class="section-title">节点入度表</div>
                    <div class="scroll-content">
                        <table class="data-table">
                            <thead>
                                <tr><th>节点</th><th>入度</th><th>状态</th></tr>
                            </thead>
                            <tbody id="nodeTableBody"></tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Right: Queue & Result -->
                <div class="section-right">
                    <div class="section-title" style="border-bottom:1px solid var(--border-color); background:#f8fafc;">
                        <span>FIFO 队列</span>
                    </div>
                    <div style="background:#f8fafc; border-bottom:1px solid var(--border-color);">
                        <div id="queueContainer" class="queue-container">
                            <span class="queue-label">HEAD</span>
                            <!-- Queue Items -->
                        </div>
                    </div>
                    
                    <div class="section-title">拓扑序列 (Result)</div>
                    <div class="scroll-content">
                        <div id="resultContainer" class="result-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- 1. Graph Data (Aligned Layout) ---
        const nodes = [
            { id: 'A', x: 60, y: 300 },   // Start
            { id: 'B', x: 180, y: 150 },  // Top Branch Start
            { id: 'C', x: 180, y: 450 },  // Bottom Branch Start
            { id: 'G', x: 320, y: 150 },  // B->G
            { id: 'H', x: 320, y: 450 },  // C->H
            
            // Cycle Group (Aligned)
            { id: 'D', x: 460, y: 150 },  // G->D (Collinear with B, G)
            { id: 'E', x: 460, y: 450 },  // H->E (Collinear with C, H) - E below D
            { id: 'F', x: 600, y: 300 }   // Triangle Point
        ];

        // Edges
        const edges = [
            // Left DAG part
            { from: 'A', to: 'B' },
            { from: 'A', to: 'C' },
            { from: 'B', to: 'G' },
            { from: 'B', to: 'H' }, // Diagonal B -> H
            { from: 'C', to: 'H' },
            
            { from: 'H', to: 'G' }, // New Edge added here: H -> G
            
            // Connecting to Cycle
            { from: 'G', to: 'D' }, 
            { from: 'H', to: 'E' },
            
            // The Cycle: D -> E -> F -> D
            { from: 'D', to: 'E' }, // Vertical D -> E
            { from: 'E', to: 'F' },
            { from: 'F', to: 'D' }  // Back edge
        ];

        // --- 2. Canvas & Helpers ---
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        let canvasDims = { width: 800, height: 600 };

        function setupCanvas() {
            const container = document.getElementById('canvas-wrapper');
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            // Restore padding calculation for card style
            const w = rect.width - 40; 
            const h = rect.height - 40;
            if (w <= 0) return { width: 800, height: 600 };
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${w}px`; canvas.style.height = `${h}px`;
            return { width: w, height: h };
        }

        function getScaleFactors(width, height) {
            const scaleX = width / 800; const scaleY = height / 600;
            const scale = Math.min(scaleX, scaleY);
            const offsetX = (width - 800 * scale) / 2;
            const offsetY = (height - 600 * scale) / 2;
            return { scale, offsetX, offsetY };
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, r, color, lineWidth) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const startX = fromX + r * Math.cos(angle);
            const startY = fromY + r * Math.sin(angle);
            const endX = toX - r * Math.cos(angle);
            const endY = toY - r * Math.sin(angle);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();

            // Arrow head
            const headLen = 12 * (lineWidth / 2); 
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(endX, endY);
            ctx.fillStyle = color;
            ctx.fill();
        }

        // --- 3. Kahn's Algorithm Logic ---
        function generateSteps() {
            const steps = [];
            const inDegrees = {};
            const adj = {};
            
            // Init
            nodes.forEach(n => { inDegrees[n.id] = 0; adj[n.id] = []; });
            edges.forEach(e => {
                adj[e.from].push(e.to);
                inDegrees[e.to]++;
            });

            const queue = [];
            const result = [];
            
            // Step 0: Init State
            steps.push({
                type: 'INIT',
                msg: '初始化：计算所有节点的初始入度。',
                inDegrees: {...inDegrees}, queue: [...queue], result: [...result],
                currNode: null, activeEdge: null
            });

            // Step 1: Find 0 in-degree nodes
            nodes.forEach(n => {
                if (inDegrees[n.id] === 0) {
                    queue.push(n.id);
                }
            });
            
            steps.push({
                type: 'ENQUEUE_INIT',
                msg: `寻找入度为 0 的节点: [${queue.join(', ')}]，加入队列。`,
                inDegrees: {...inDegrees}, queue: [...queue], result: [...result],
                currNode: null, activeEdge: null
            });

            while (queue.length > 0) {
                // Dequeue
                const u = queue.shift();
                result.push(u);
                
                steps.push({
                    type: 'DEQUEUE',
                    msg: `从队列取出节点 ${u}，加入拓扑序列。准备处理其邻居。`,
                    inDegrees: {...inDegrees}, queue: [...queue], result: [...result],
                    currNode: u, activeEdge: null
                });

                // Process Neighbors
                for (let v of adj[u]) {
                    inDegrees[v]--;
                    
                    let msg = `处理边 ${u}->${v}：节点 ${v} 的入度减 1 (当前: ${inDegrees[v]})。`;
                    let type = 'DECREMENT';
                    
                    // Snapshot before checking if 0
                    steps.push({
                        type: type, msg: msg,
                        inDegrees: {...inDegrees}, queue: [...queue], result: [...result],
                        currNode: u, activeEdge: {from: u, to: v}
                    });

                    if (inDegrees[v] === 0) {
                        queue.push(v);
                        steps.push({
                            type: 'ENQUEUE',
                            msg: `节点 ${v} 的入度变为 0！加入队列。`,
                            inDegrees: {...inDegrees}, queue: [...queue], result: [...result],
                            currNode: u, activeEdge: {from: u, to: v}, targetNode: v
                        });
                    }
                }
            }

            if (result.length === nodes.length) {
                steps.push({
                    type: 'DONE', msg: '队列为空且所有节点已排序。算法完成，这是一个 DAG。',
                    inDegrees: {...inDegrees}, queue: [], result: [...result],
                    currNode: null, activeEdge: null
                });
            } else {
                steps.push({
                    type: 'CYCLE', msg: '队列为空但仍有节点未排序。图中存在环！',
                    inDegrees: {...inDegrees}, queue: [], result: [...result],
                    currNode: null, activeEdge: null
                });
            }

            return steps;
        }

        // --- 4. Render Logic ---
        const steps = generateSteps();
        let currentStepIndex = 0;
        let animationInterval = null;

        function drawGraph(state) {
            const { width, height } = canvasDims;
            const { scale, offsetX, offsetY } = getScaleFactors(width, height);
            ctx.clearRect(0, 0, width, height);
            const tx = (val) => val * scale + offsetX;
            const ty = (val) => val * scale + offsetY;

            // Draw Edges
            edges.forEach(edge => {
                const n1 = nodes.find(n => n.id === edge.from);
                const n2 = nodes.find(n => n.id === edge.to);
                const x1 = tx(n1.x), y1 = ty(n1.y);
                const x2 = tx(n2.x), y2 = ty(n2.y);
                const r = 36 * scale;

                let color = '#e2e8f0'; let width = 2 * scale;

                // Highlight active edge
                if (state.activeEdge && state.activeEdge.from === edge.from && state.activeEdge.to === edge.to) {
                    color = '#fca5a5'; width = 4 * scale; // Red/Pink for processing
                } 
                // Fade out edges from processed nodes
                else if (state.result.includes(edge.from)) {
                    color = '#f1f5f9'; // Very light gray
                }

                drawArrow(ctx, x1, y1, x2, y2, r, color, width);
            });

            // Draw Nodes
            nodes.forEach(node => {
                const x = tx(node.x), y = ty(node.y);
                const r = 36 * scale;
                const inDeg = state.inDegrees[node.id];
                const isProcessed = state.result.includes(node.id);
                const isProcessing = state.currNode === node.id;
                const isReady = inDeg === 0 && !isProcessed; // In queue

                let bg = 'white'; let border = '#cbd5e1'; let textCol = '#475569'; let shadowCol = 'transparent';
                
                // Color Logic Fix: Priority Order Changed
                // 1. Processing (Red) - Highest Priority
                if (isProcessing) {
                    bg = '#fca5a5'; border = '#ef4444'; shadowCol = 'rgba(239, 68, 68, 0.4)'; // Red (Active)
                } 
                // 2. Ready (Green)
                else if (isReady) {
                    bg = '#dcfce7'; border = '#22c55e'; shadowCol = 'rgba(34, 197, 94, 0.3)'; // Green (Ready)
                } 
                // 3. Processed (Blue)
                else if (isProcessed) {
                    bg = '#eff6ff'; border = '#3b82f6'; textCol = '#1e40af'; // Blue (Done)
                } 
                // 4. Waiting (White)
                else {
                    bg = '#ffffff'; border = '#94a3b8'; // Waiting
                }

                if (isProcessing || isReady) {
                    ctx.shadowBlur = 20; ctx.shadowColor = shadowCol; ctx.lineWidth = 4 * scale;
                } else {
                    ctx.shadowBlur = 0; ctx.lineWidth = 2 * scale;
                }

                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = bg; ctx.fill();
                ctx.strokeStyle = border; ctx.stroke();
                ctx.shadowBlur = 0; 

                // ID
                ctx.fillStyle = textCol; 
                ctx.font = `bold ${26 * scale}px "Plus Jakarta Sans"`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(node.id, x, y - 5 * scale);

                // In-Degree Badge
                const badgeY = y + 15 * scale;
                const degText = `In: ${inDeg}`;
                ctx.font = `600 ${14 * scale}px "JetBrains Mono"`;
                
                ctx.fillStyle = (inDeg === 0 && !isProcessed) ? '#166534' : '#64748b';
                ctx.fillText(degText, x, badgeY);
            });
        }

        function updateUI(state) {
            document.getElementById('statusText').innerText = state.msg;

            // Update Table
            const tbody = document.getElementById('nodeTableBody');
            tbody.innerHTML = '';
            nodes.forEach(node => {
                const tr = document.createElement('tr');
                const deg = state.inDegrees[node.id];
                const isDone = state.result.includes(node.id);
                const isReady = deg === 0 && !isDone;
                
                let statusBadge = '';
                if(isDone) statusBadge = '<span class="color-tag" style="background:#eff6ff; color:#1e40af;">Sorted</span>';
                else if(isReady) statusBadge = '<span class="color-tag" style="background:#dcfce7; color:#166534;">Ready</span>';
                else statusBadge = '<span class="color-tag" style="background:#f1f5f9; color:#64748b;">Waiting</span>';

                // Highlight row if node is active
                if (state.currNode === node.id || state.targetNode === node.id) tr.className = 'anim-row-update';

                tr.innerHTML = `<td style="font-weight:600;">${node.id}</td><td style="font-family:'JetBrains Mono'; font-weight:bold;">${deg}</td><td>${statusBadge}</td>`;
                tbody.appendChild(tr);
            });

            // Update Queue
            const queueContainer = document.getElementById('queueContainer');
            // Rebuild queue
            queueContainer.innerHTML = '<span class="queue-label">HEAD</span>';
            if (state.queue.length === 0) {
                queueContainer.innerHTML += '<span style="font-size:0.8rem; color:#94a3b8; font-style:italic;">Empty</span>';
            } else {
                state.queue.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'queue-item';
                    el.innerText = item;
                    queueContainer.appendChild(el);
                });
            }

            // Update Result
            const resultContainer = document.getElementById('resultContainer');
            resultContainer.innerHTML = '';
            state.result.forEach((item, index) => {
                if (index > 0) {
                    const arrow = document.createElement('span');
                    arrow.className = 'result-arrow';
                    arrow.innerHTML = '→';
                    resultContainer.appendChild(arrow);
                }
                const el = document.createElement('div');
                el.className = 'result-item';
                el.innerText = item;
                resultContainer.appendChild(el);
            });

            document.getElementById('btnPrev').disabled = currentStepIndex === 0;
            document.getElementById('btnNext').disabled = currentStepIndex === steps.length - 1;
        }

        function render() {
            const state = steps[currentStepIndex];
            requestAnimationFrame(() => {
                drawGraph(state);
                updateUI(state);
            });
        }

        const btnNext = document.getElementById('btnNext');
        const btnPrev = document.getElementById('btnPrev');
        const btnPlay = document.getElementById('btnPlay');
        const btnReset = document.getElementById('btnReset');

        function nextStep() { if (currentStepIndex < steps.length - 1) { currentStepIndex++; render(); } else stopPlay(); }
        function prevStep() { if (currentStepIndex > 0) { currentStepIndex--; render(); } }
        function reset() { stopPlay(); currentStepIndex = 0; render(); }
        
        function togglePlay() {
            if (animationInterval) stopPlay();
            else {
                if (currentStepIndex === steps.length - 1) currentStepIndex = 0;
                btnPlay.classList.add('btn-danger');
                btnPlay.classList.remove('btn-primary');
                btnPlay.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg><span>暂停</span>`;
                nextStep();
                animationInterval = setInterval(nextStep, 1500);
            }
        }
        function stopPlay() {
            clearInterval(animationInterval); animationInterval = null;
            btnPlay.classList.remove('btn-danger');
            btnPlay.classList.add('btn-primary');
            btnPlay.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg><span>播放</span>`;
        }

        btnNext.addEventListener('click', () => { stopPlay(); nextStep(); });
        btnPrev.addEventListener('click', () => { stopPlay(); prevStep(); });
        btnReset.addEventListener('click', reset);
        btnPlay.addEventListener('click', togglePlay);

        window.addEventListener('load', () => { canvasDims = setupCanvas(); render(); });
        window.addEventListener('resize', () => { canvasDims = setupCanvas(); render(); });

    </script>
</body>
</html>